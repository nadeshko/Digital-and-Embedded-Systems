CCS PCH C Compiler, Version 5.093d, 1               14-Mar-20 14:21
Compiler operating in Evaluation Mode
To obtain a fully enabled compiler visit www.ccsinfo.com/products

               Filename:   E:\Lab 6\new.lst

               ROM used:   6312 bytes (5%)
                           Largest free fragment is 65536
               RAM used:   126 (3%) at main() level
                           316 (9%) worst case
               Stack used: 4 locations (2 in main + 2 for interrupts)
               Stack size: 31

00000:  GOTO   1604
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  FF8,18
00048:  MOVFF  FFB,19
0004C:  MOVFF  00,0E
00050:  MOVFF  01,0F
00054:  MOVFF  02,10
00058:  MOVFF  03,11
0005C:  MOVLB  E
0005E:  BTFSS  xC5.5
00060:  GOTO   006A
00064:  BTFSC  xCD.5
00066:  GOTO   00DA
0006A:  MOVFF  0E,00
0006E:  MOVFF  0F,01
00072:  MOVFF  10,02
00076:  MOVFF  11,03
0007A:  MOVFF  0C,FE9
0007E:  MOVFF  07,FEA
00082:  BSF    07.7
00084:  MOVFF  08,FE1
00088:  MOVFF  09,FE2
0008C:  MOVFF  0A,FD9
00090:  MOVFF  0B,FDA
00094:  MOVFF  12,FF3
00098:  MOVFF  13,FF4
0009C:  MOVFF  14,FFA
000A0:  MOVFF  15,FF5
000A4:  MOVFF  16,FF6
000A8:  MOVFF  17,FF7
000AC:  MOVFF  18,FF8
000B0:  MOVFF  19,FFB
000B4:  MOVF   04,W
000B6:  MOVFF  06,FE0
000BA:  MOVFF  05,FD8
000BE:  RETFIE 0
.................... #include <18F27K40.h>
.................... //////////// Standard Header file for the PIC18F27K40 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F27K40
*
0011C:  DATA 4F,4B
0011E:  DATA 0A,00
00120:  DATA 4F,4B
00122:  DATA 0A,00
00124:  DATA 4F,4B
00126:  DATA 0A,00
00128:  DATA 4F,4B
0012A:  DATA 0A,00
0012C:  DATA 4F,4B
0012E:  DATA 0A,00
00130:  DATA 4F,4B
00132:  DATA 0A,00
00134:  DATA 4F,4B
00136:  DATA 0A,00
00138:  DATA 4F,4B
0013A:  DATA 0A,00
0013C:  DATA 4F,4B
0013E:  DATA 0A,00
00140:  DATA 4F,4B
00142:  DATA 0A,00
00144:  DATA 4F,4B
00146:  DATA 0A,00
00148:  DATA 4F,4B
0014A:  DATA 0A,00
0014C:  DATA 4F,4B
0014E:  DATA 0A,00
00150:  DATA 49,6E
00152:  DATA 76,61
00154:  DATA 6C,69
00156:  DATA 64,20
00158:  DATA 49,6E
0015A:  DATA 70,75
0015C:  DATA 74,21
0015E:  DATA 20,54
00160:  DATA 72,79
00162:  DATA 20,41
00164:  DATA 67,61
00166:  DATA 69,6E
00168:  DATA 2E,0A
0016A:  DATA 00,00
0016C:  DATA 09,09
0016E:  DATA 2A,2A
00170:  DATA 2A,47
00172:  DATA 72,6F
00174:  DATA 75,70
00176:  DATA 20,32
00178:  DATA 33,20
0017A:  DATA 45,45
0017C:  DATA 32,41
0017E:  DATA 20,4C
00180:  DATA 61,62
00182:  DATA 20,36
00184:  DATA 2A,2A
00186:  DATA 2A,0A
00188:  DATA 0D,00
0018A:  DATA 41,76
0018C:  DATA 61,69
0018E:  DATA 6C,61
00190:  DATA 62,6C
00192:  DATA 65,20
00194:  DATA 43,6F
00196:  DATA 6D,6D
00198:  DATA 61,6E
0019A:  DATA 64,73
0019C:  DATA 3A,0A
0019E:  DATA 00,00
001A0:  DATA 20,20
001A2:  DATA 20,2D
001A4:  DATA 54,75
001A6:  DATA 72,6E
001A8:  DATA 69,6E
001AA:  DATA 67,20
001AC:  DATA 4C,45
001AE:  DATA 44,73
001B0:  DATA 20,4F
001B2:  DATA 4E,2D
001B4:  DATA 20,20
001B6:  DATA 20,20
001B8:  DATA 20,20
001BA:  DATA 20,20
001BC:  DATA 20,2D
001BE:  DATA 54,75
001C0:  DATA 72,6E
001C2:  DATA 69,6E
001C4:  DATA 67,20
001C6:  DATA 4C,45
001C8:  DATA 44,73
001CA:  DATA 20,4F
001CC:  DATA 46,46
001CE:  DATA 2D,20
001D0:  DATA 20,20
001D2:  DATA 20,20
001D4:  DATA 20,20
001D6:  DATA 20,20
001D8:  DATA 20,2D
001DA:  DATA 46,6C
001DC:  DATA 61,73
001DE:  DATA 68,69
001E0:  DATA 6E,67
001E2:  DATA 20,4C
001E4:  DATA 45,44
001E6:  DATA 73,2D
001E8:  DATA 0A,00
001EA:  DATA 20,20
001EC:  DATA 20,20
001EE:  DATA 20,20
001F0:  DATA 20,4C
001F2:  DATA 45,44
001F4:  DATA 20,78
001F6:  DATA 20,6F
001F8:  DATA 6E,20
001FA:  DATA 20,20
001FC:  DATA 20,20
001FE:  DATA 20,20
00200:  DATA 20,20
00202:  DATA 20,20
00204:  DATA 20,20
00206:  DATA 20,20
00208:  DATA 20,20
0020A:  DATA 20,4C
0020C:  DATA 45,44
0020E:  DATA 20,78
00210:  DATA 20,6F
00212:  DATA 66,66
00214:  DATA 20,20
00216:  DATA 20,20
00218:  DATA 20,20
0021A:  DATA 20,20
0021C:  DATA 20,20
0021E:  DATA 20,20
00220:  DATA 20,20
00222:  DATA 20,20
00224:  DATA 20,4C
00226:  DATA 45,44
00228:  DATA 20,78
0022A:  DATA 20,66
0022C:  DATA 6C,61
0022E:  DATA 73,68
00230:  DATA 0A,0D
00232:  DATA 00,00
00234:  DATA 57,68
00236:  DATA 65,72
00238:  DATA 65,20
0023A:  DATA 78,20
0023C:  DATA 3D,20
0023E:  DATA 31,2C
00240:  DATA 32,2C
00242:  DATA 33,20
00244:  DATA 6F,72
00246:  DATA 20,34
00248:  DATA 0A,0D
0024A:  DATA 6C,6F
0024C:  DATA 77,65
0024E:  DATA 72,20
00250:  DATA 61,6E
00252:  DATA 64,20
00254:  DATA 75,70
00256:  DATA 70,65
00258:  DATA 72,63
0025A:  DATA 61,73
0025C:  DATA 65,20
0025E:  DATA 64,6F
00260:  DATA 65,73
00262:  DATA 20,6E
00264:  DATA 6F,74
00266:  DATA 20,6D
00268:  DATA 61,74
0026A:  DATA 74,65
0026C:  DATA 72,0A
0026E:  DATA 0D,00
00270:  DATA 49,4D
00272:  DATA 50,4F
00274:  DATA 52,54
00276:  DATA 41,4E
00278:  DATA 54,3A
0027A:  DATA 20,53
0027C:  DATA 70,61
0027E:  DATA 63,65
00280:  DATA 20,61
00282:  DATA 72,65
00284:  DATA 20,72
00286:  DATA 65,71
00288:  DATA 75,69
0028A:  DATA 72,65
0028C:  DATA 64,21
0028E:  DATA 21,21
00290:  DATA 20,42
00292:  DATA 61,63
00294:  DATA 6B,73
00296:  DATA 70,61
00298:  DATA 63,65
0029A:  DATA 20,64
0029C:  DATA 6F,65
0029E:  DATA 73,20
002A0:  DATA 6E,6F
002A2:  DATA 74,20
002A4:  DATA 77,6F
002A6:  DATA 72,6B
002A8:  DATA 21,0A
002AA:  DATA 0D,00
002AC:  DATA 2D,43
002AE:  DATA 68,61
002B0:  DATA 6E,67
002B2:  DATA 69,6E
002B4:  DATA 67,20
002B6:  DATA 4C,45
002B8:  DATA 44,20
002BA:  DATA 42,72
002BC:  DATA 69,67
002BE:  DATA 68,74
002C0:  DATA 6E,65
002C2:  DATA 73,73
002C4:  DATA 2D,0A
002C6:  DATA 00,00
002C8:  DATA 42,72
002CA:  DATA 69,67
002CC:  DATA 68,74
002CE:  DATA 6E,65
002D0:  DATA 73,73
002D2:  DATA 5B,76
002D4:  DATA 61,6C
002D6:  DATA 75,65
002D8:  DATA 5D,2C
002DA:  DATA 20,77
002DC:  DATA 68,65
002DE:  DATA 72,65
002E0:  DATA 20,76
002E2:  DATA 61,6C
002E4:  DATA 75,65
002E6:  DATA 20,3D
002E8:  DATA 20,30
002EA:  DATA 20,2D
002EC:  DATA 20,39
002EE:  DATA 39,20
002F0:  DATA 28,70
002F2:  DATA 6F,73
002F4:  DATA 69,74
002F6:  DATA 69,76
002F8:  DATA 65,20
002FA:  DATA 6E,75
002FC:  DATA 6D,62
002FE:  DATA 65,72
00300:  DATA 73,29
00302:  DATA 0A,0D
00304:  DATA 2D,2D
00306:  DATA 2D,2D
00308:  DATA 2D,2D
0030A:  DATA 2D,2D
0030C:  DATA 2D,2D
0030E:  DATA 2D,2D
00310:  DATA 2D,2D
00312:  DATA 2D,2D
00314:  DATA 2D,2D
00316:  DATA 2D,2D
00318:  DATA 2D,2D
0031A:  DATA 2D,2D
0031C:  DATA 2D,2D
0031E:  DATA 2D,2D
00320:  DATA 2D,2D
00322:  DATA 2D,2D
00324:  DATA 2D,2D
00326:  DATA 2D,2D
00328:  DATA 2D,2D
0032A:  DATA 2D,2D
0032C:  DATA 2D,2D
0032E:  DATA 2D,2D
00330:  DATA 0A,0D
00332:  DATA 00,00
*
00372:  TBLRD*+
00374:  MOVF   FF5,F
00376:  BZ    0398
00378:  MOVFF  FF6,10D
0037C:  MOVFF  FF7,10E
00380:  MOVFF  FF8,10F
00384:  MOVFF  FF5,110
00388:  RCALL  035A
0038A:  MOVFF  10D,FF6
0038E:  MOVFF  10E,FF7
00392:  MOVFF  10F,FF8
00396:  BRA    0372
00398:  RETURN 0
0039A:  MOVF   FEF,F
0039C:  BZ    03BC
0039E:  MOVFF  FEA,7E
003A2:  MOVFF  FE9,7D
003A6:  MOVFF  FEF,110
003AA:  RCALL  035A
003AC:  MOVFF  7E,FEA
003B0:  MOVFF  7D,FE9
003B4:  INCF   FE9,F
003B6:  BTFSC  FD8.2
003B8:  INCF   FEA,F
003BA:  BRA    039A
003BC:  GOTO   185E (RETURN)
*
005C8:  MOVLB  1
005CA:  MOVF   x24,W
005CC:  BTFSC  FD8.2
005CE:  BRA    06B2
005D0:  MOVWF  00
005D2:  MOVF   x28,W
005D4:  BTFSC  FD8.2
005D6:  BRA    06B2
005D8:  ADDWF  00,F
005DA:  BNC   05E4
005DC:  MOVLW  81
005DE:  ADDWF  00,F
005E0:  BC    06B2
005E2:  BRA    05EC
005E4:  MOVLW  7F
005E6:  SUBWF  00,F
005E8:  BNC   06B2
005EA:  BZ    06B2
005EC:  MOVFF  125,12C
005F0:  MOVF   x29,W
005F2:  XORWF  x2C,F
005F4:  BSF    x25.7
005F6:  BSF    x29.7
005F8:  MOVF   x27,W
005FA:  MULWF  x2B
005FC:  MOVFF  FF4,12E
00600:  MOVF   x26,W
00602:  MULWF  x2A
00604:  MOVFF  FF4,03
00608:  MOVFF  FF3,12D
0060C:  MULWF  x2B
0060E:  MOVF   FF3,W
00610:  ADDWF  x2E,F
00612:  MOVF   FF4,W
00614:  ADDWFC x2D,F
00616:  MOVLW  00
00618:  ADDWFC 03,F
0061A:  MOVF   x27,W
0061C:  MULWF  x2A
0061E:  MOVF   FF3,W
00620:  ADDWF  x2E,F
00622:  MOVF   FF4,W
00624:  ADDWFC x2D,F
00626:  MOVLW  00
00628:  CLRF   02
0062A:  ADDWFC 03,F
0062C:  ADDWFC 02,F
0062E:  MOVF   x25,W
00630:  MULWF  x2B
00632:  MOVF   FF3,W
00634:  ADDWF  x2D,F
00636:  MOVF   FF4,W
00638:  ADDWFC 03,F
0063A:  MOVLW  00
0063C:  ADDWFC 02,F
0063E:  MOVF   x25,W
00640:  MULWF  x2A
00642:  MOVF   FF3,W
00644:  ADDWF  03,F
00646:  MOVF   FF4,W
00648:  ADDWFC 02,F
0064A:  MOVLW  00
0064C:  CLRF   01
0064E:  ADDWFC 01,F
00650:  MOVF   x27,W
00652:  MULWF  x29
00654:  MOVF   FF3,W
00656:  ADDWF  x2D,F
00658:  MOVF   FF4,W
0065A:  ADDWFC 03,F
0065C:  MOVLW  00
0065E:  ADDWFC 02,F
00660:  ADDWFC 01,F
00662:  MOVF   x26,W
00664:  MULWF  x29
00666:  MOVF   FF3,W
00668:  ADDWF  03,F
0066A:  MOVF   FF4,W
0066C:  ADDWFC 02,F
0066E:  MOVLW  00
00670:  ADDWFC 01,F
00672:  MOVF   x25,W
00674:  MULWF  x29
00676:  MOVF   FF3,W
00678:  ADDWF  02,F
0067A:  MOVF   FF4,W
0067C:  ADDWFC 01,F
0067E:  INCF   00,F
00680:  BTFSC  01.7
00682:  BRA    068E
00684:  RLCF   x2D,F
00686:  RLCF   03,F
00688:  RLCF   02,F
0068A:  RLCF   01,F
0068C:  DECF   00,F
0068E:  MOVLW  00
00690:  BTFSS  x2D.7
00692:  BRA    06A8
00694:  INCF   03,F
00696:  ADDWFC 02,F
00698:  ADDWFC 01,F
0069A:  MOVF   01,W
0069C:  BNZ   06A8
0069E:  MOVF   02,W
006A0:  BNZ   06A8
006A2:  MOVF   03,W
006A4:  BNZ   06A8
006A6:  INCF   00,F
006A8:  BTFSC  x2C.7
006AA:  BSF    01.7
006AC:  BTFSS  x2C.7
006AE:  BCF    01.7
006B0:  BRA    06BA
006B2:  CLRF   00
006B4:  CLRF   01
006B6:  CLRF   02
006B8:  CLRF   03
006BA:  MOVLB  0
006BC:  RETURN 0
006BE:  MOVLW  8E
006C0:  MOVWF  00
006C2:  MOVFF  129,01
006C6:  MOVFF  128,02
006CA:  CLRF   03
006CC:  MOVF   01,F
006CE:  BNZ   06E2
006D0:  MOVFF  02,01
006D4:  CLRF   02
006D6:  MOVLW  08
006D8:  SUBWF  00,F
006DA:  MOVF   01,F
006DC:  BNZ   06E2
006DE:  CLRF   00
006E0:  BRA    06F2
006E2:  BCF    FD8.0
006E4:  BTFSC  01.7
006E6:  BRA    06F0
006E8:  RLCF   02,F
006EA:  RLCF   01,F
006EC:  DECF   00,F
006EE:  BRA    06E2
006F0:  BCF    01.7
006F2:  RETURN 0
006F4:  MOVLB  1
006F6:  MOVF   x28,W
006F8:  BTFSC  FD8.2
006FA:  BRA    0846
006FC:  MOVWF  x34
006FE:  MOVF   x2C,W
00700:  BTFSC  FD8.2
00702:  BRA    0846
00704:  SUBWF  x34,F
00706:  BNC   0712
00708:  MOVLW  7F
0070A:  ADDWF  x34,F
0070C:  BTFSC  FD8.0
0070E:  BRA    0846
00710:  BRA    071E
00712:  MOVLW  81
00714:  SUBWF  x34,F
00716:  BTFSS  FD8.0
00718:  BRA    0846
0071A:  BTFSC  FD8.2
0071C:  BRA    0846
0071E:  MOVFF  134,00
00722:  CLRF   01
00724:  CLRF   02
00726:  CLRF   03
00728:  CLRF   x33
0072A:  MOVFF  129,132
0072E:  BSF    x32.7
00730:  MOVFF  12A,131
00734:  MOVFF  12B,130
00738:  MOVLW  19
0073A:  MOVWF  x34
0073C:  MOVF   x2F,W
0073E:  SUBWF  x30,F
00740:  BC    075C
00742:  MOVLW  01
00744:  SUBWF  x31,F
00746:  BC    075C
00748:  SUBWF  x32,F
0074A:  BC    075C
0074C:  SUBWF  x33,F
0074E:  BC    075C
00750:  INCF   x33,F
00752:  INCF   x32,F
00754:  INCF   x31,F
00756:  MOVF   x2F,W
00758:  ADDWF  x30,F
0075A:  BRA    07AC
0075C:  MOVF   x2E,W
0075E:  SUBWF  x31,F
00760:  BC    0786
00762:  MOVLW  01
00764:  SUBWF  x32,F
00766:  BC    0786
00768:  SUBWF  x33,F
0076A:  BC    0786
0076C:  INCF   x33,F
0076E:  INCF   x32,F
00770:  MOVF   x2E,W
00772:  ADDWF  x31,F
00774:  MOVF   x2F,W
00776:  ADDWF  x30,F
00778:  BNC   07AC
0077A:  INCF   x31,F
0077C:  BNZ   07AC
0077E:  INCF   x32,F
00780:  BNZ   07AC
00782:  INCF   x33,F
00784:  BRA    07AC
00786:  MOVF   x2D,W
00788:  IORLW  80
0078A:  SUBWF  x32,F
0078C:  BC    07AA
0078E:  MOVLW  01
00790:  SUBWF  x33,F
00792:  BC    07AA
00794:  INCF   x33,F
00796:  MOVF   x2D,W
00798:  IORLW  80
0079A:  ADDWF  x32,F
0079C:  MOVF   x2E,W
0079E:  ADDWF  x31,F
007A0:  BNC   0774
007A2:  INCF   x32,F
007A4:  BNZ   0774
007A6:  INCF   x33,F
007A8:  BRA    0774
007AA:  BSF    03.0
007AC:  DECFSZ x34,F
007AE:  BRA    07B2
007B0:  BRA    07C8
007B2:  BCF    FD8.0
007B4:  RLCF   x30,F
007B6:  RLCF   x31,F
007B8:  RLCF   x32,F
007BA:  RLCF   x33,F
007BC:  BCF    FD8.0
007BE:  RLCF   03,F
007C0:  RLCF   02,F
007C2:  RLCF   01,F
007C4:  RLCF   x35,F
007C6:  BRA    073C
007C8:  BTFSS  x35.0
007CA:  BRA    07D8
007CC:  BCF    FD8.0
007CE:  RRCF   01,F
007D0:  RRCF   02,F
007D2:  RRCF   03,F
007D4:  RRCF   x35,F
007D6:  BRA    07DC
007D8:  DECF   00,F
007DA:  BZ    0846
007DC:  BTFSC  x35.7
007DE:  BRA    081C
007E0:  BCF    FD8.0
007E2:  RLCF   x30,F
007E4:  RLCF   x31,F
007E6:  RLCF   x32,F
007E8:  RLCF   x33,F
007EA:  MOVF   x2F,W
007EC:  SUBWF  x30,F
007EE:  BC    07FE
007F0:  MOVLW  01
007F2:  SUBWF  x31,F
007F4:  BC    07FE
007F6:  SUBWF  x32,F
007F8:  BC    07FE
007FA:  SUBWF  x33,F
007FC:  BNC   0832
007FE:  MOVF   x2E,W
00800:  SUBWF  x31,F
00802:  BC    080E
00804:  MOVLW  01
00806:  SUBWF  x32,F
00808:  BC    080E
0080A:  SUBWF  x33,F
0080C:  BNC   0832
0080E:  MOVF   x2D,W
00810:  IORLW  80
00812:  SUBWF  x32,F
00814:  BC    081C
00816:  MOVLW  01
00818:  SUBWF  x33,F
0081A:  BNC   0832
0081C:  INCF   03,F
0081E:  BNZ   0832
00820:  INCF   02,F
00822:  BNZ   0832
00824:  INCF   01,F
00826:  BNZ   0832
00828:  INCF   00,F
0082A:  BZ    0846
0082C:  RRCF   01,F
0082E:  RRCF   02,F
00830:  RRCF   03,F
00832:  MOVFF  129,134
00836:  MOVF   x2D,W
00838:  XORWF  x34,F
0083A:  BTFSS  x34.7
0083C:  BRA    0842
0083E:  BSF    01.7
00840:  BRA    084E
00842:  BCF    01.7
00844:  BRA    084E
00846:  CLRF   00
00848:  CLRF   01
0084A:  CLRF   02
0084C:  CLRF   03
0084E:  MOVLB  0
00850:  RETURN 0
00852:  MOVLW  80
00854:  BTFSS  FD8.1
00856:  BRA    085C
00858:  MOVLB  1
0085A:  XORWF  x2D,F
0085C:  MOVLB  1
0085E:  CLRF   x32
00860:  CLRF   x33
00862:  MOVFF  129,131
00866:  MOVF   x2D,W
00868:  XORWF  x31,F
0086A:  MOVF   x28,W
0086C:  BTFSC  FD8.2
0086E:  BRA    0A2E
00870:  MOVWF  x30
00872:  MOVWF  00
00874:  MOVF   x2C,W
00876:  BTFSC  FD8.2
00878:  BRA    0A40
0087A:  SUBWF  x30,F
0087C:  BTFSC  FD8.2
0087E:  BRA    0986
00880:  BNC   08FE
00882:  MOVFF  12D,136
00886:  BSF    x36.7
00888:  MOVFF  12E,135
0088C:  MOVFF  12F,134
00890:  CLRF   x33
00892:  BCF    FD8.0
00894:  RRCF   x36,F
00896:  RRCF   x35,F
00898:  RRCF   x34,F
0089A:  RRCF   x33,F
0089C:  DECFSZ x30,F
0089E:  BRA    0890
008A0:  BTFSS  x31.7
008A2:  BRA    08AA
008A4:  BSF    x32.0
008A6:  BRA    0A68
008A8:  BCF    x32.0
008AA:  BCF    x30.0
008AC:  BSF    x32.4
008AE:  MOVLW  01
008B0:  MOVWF  FEA
008B2:  MOVLW  2B
008B4:  MOVWF  FE9
008B6:  BRA    0A8E
008B8:  BCF    x32.4
008BA:  BTFSC  x31.7
008BC:  BRA    08D2
008BE:  BTFSS  x30.0
008C0:  BRA    08E8
008C2:  RRCF   x36,F
008C4:  RRCF   x35,F
008C6:  RRCF   x34,F
008C8:  RRCF   x33,F
008CA:  INCF   00,F
008CC:  BTFSC  FD8.2
008CE:  BRA    0A5E
008D0:  BRA    08E8
008D2:  BTFSC  x36.7
008D4:  BRA    08EE
008D6:  BCF    FD8.0
008D8:  RLCF   x33,F
008DA:  RLCF   x34,F
008DC:  RLCF   x35,F
008DE:  RLCF   x36,F
008E0:  DECF   00,F
008E2:  BTFSC  FD8.2
008E4:  BRA    0A5E
008E6:  BRA    08D2
008E8:  BSF    x32.6
008EA:  BRA    09C6
008EC:  BCF    x32.6
008EE:  MOVFF  129,131
008F2:  BTFSS  x29.7
008F4:  BRA    08FA
008F6:  BSF    x36.7
008F8:  BRA    0A50
008FA:  BCF    x36.7
008FC:  BRA    0A50
008FE:  MOVFF  12C,130
00902:  MOVFF  12C,00
00906:  MOVF   x28,W
00908:  SUBWF  x30,F
0090A:  MOVFF  129,136
0090E:  BSF    x36.7
00910:  MOVFF  12A,135
00914:  MOVFF  12B,134
00918:  CLRF   x33
0091A:  BCF    FD8.0
0091C:  RRCF   x36,F
0091E:  RRCF   x35,F
00920:  RRCF   x34,F
00922:  RRCF   x33,F
00924:  DECFSZ x30,F
00926:  BRA    0918
00928:  BTFSS  x31.7
0092A:  BRA    0932
0092C:  BSF    x32.1
0092E:  BRA    0A68
00930:  BCF    x32.1
00932:  BCF    x30.0
00934:  BSF    x32.5
00936:  MOVLW  01
00938:  MOVWF  FEA
0093A:  MOVLW  2F
0093C:  MOVWF  FE9
0093E:  BRA    0A8E
00940:  BCF    x32.5
00942:  BTFSC  x31.7
00944:  BRA    095A
00946:  BTFSS  x30.0
00948:  BRA    0970
0094A:  RRCF   x36,F
0094C:  RRCF   x35,F
0094E:  RRCF   x34,F
00950:  RRCF   x33,F
00952:  INCF   00,F
00954:  BTFSC  FD8.2
00956:  BRA    0A5E
00958:  BRA    0970
0095A:  BTFSC  x36.7
0095C:  BRA    0976
0095E:  BCF    FD8.0
00960:  RLCF   x33,F
00962:  RLCF   x34,F
00964:  RLCF   x35,F
00966:  RLCF   x36,F
00968:  DECF   00,F
0096A:  BTFSC  FD8.2
0096C:  BRA    0A5E
0096E:  BRA    095A
00970:  BSF    x32.7
00972:  BRA    09C6
00974:  BCF    x32.7
00976:  MOVFF  12D,131
0097A:  BTFSS  x2D.7
0097C:  BRA    0982
0097E:  BSF    x36.7
00980:  BRA    0A50
00982:  BCF    x36.7
00984:  BRA    0A50
00986:  MOVFF  12D,136
0098A:  BSF    x36.7
0098C:  MOVFF  12E,135
00990:  MOVFF  12F,134
00994:  BTFSS  x31.7
00996:  BRA    09A0
00998:  BCF    x36.7
0099A:  BSF    x32.2
0099C:  BRA    0A68
0099E:  BCF    x32.2
009A0:  CLRF   x33
009A2:  BCF    x30.0
009A4:  MOVLW  01
009A6:  MOVWF  FEA
009A8:  MOVLW  2B
009AA:  MOVWF  FE9
009AC:  BRA    0A8E
009AE:  BTFSC  x31.7
009B0:  BRA    09EA
009B2:  MOVFF  129,131
009B6:  BTFSS  x30.0
009B8:  BRA    09C6
009BA:  RRCF   x36,F
009BC:  RRCF   x35,F
009BE:  RRCF   x34,F
009C0:  RRCF   x33,F
009C2:  INCF   00,F
009C4:  BZ    0A5E
009C6:  BTFSS  x33.7
009C8:  BRA    09E0
009CA:  INCF   x34,F
009CC:  BNZ   09E0
009CE:  INCF   x35,F
009D0:  BNZ   09E0
009D2:  INCF   x36,F
009D4:  BNZ   09E0
009D6:  RRCF   x36,F
009D8:  RRCF   x35,F
009DA:  RRCF   x34,F
009DC:  INCF   00,F
009DE:  BZ    0A5E
009E0:  BTFSC  x32.6
009E2:  BRA    08EC
009E4:  BTFSC  x32.7
009E6:  BRA    0974
009E8:  BRA    0A22
009EA:  MOVLW  80
009EC:  XORWF  x36,F
009EE:  BTFSS  x36.7
009F0:  BRA    09FA
009F2:  BRA    0A68
009F4:  MOVFF  12D,131
009F8:  BRA    0A0E
009FA:  MOVFF  129,131
009FE:  MOVF   x36,F
00A00:  BNZ   0A0E
00A02:  MOVF   x35,F
00A04:  BNZ   0A0E
00A06:  MOVF   x34,F
00A08:  BNZ   0A0E
00A0A:  CLRF   00
00A0C:  BRA    0A50
00A0E:  BTFSC  x36.7
00A10:  BRA    0A22
00A12:  BCF    FD8.0
00A14:  RLCF   x33,F
00A16:  RLCF   x34,F
00A18:  RLCF   x35,F
00A1A:  RLCF   x36,F
00A1C:  DECFSZ 00,F
00A1E:  BRA    0A0E
00A20:  BRA    0A5E
00A22:  BTFSS  x31.7
00A24:  BRA    0A2A
00A26:  BSF    x36.7
00A28:  BRA    0A50
00A2A:  BCF    x36.7
00A2C:  BRA    0A50
00A2E:  MOVFF  12C,00
00A32:  MOVFF  12D,136
00A36:  MOVFF  12E,135
00A3A:  MOVFF  12F,134
00A3E:  BRA    0A50
00A40:  MOVFF  128,00
00A44:  MOVFF  129,136
00A48:  MOVFF  12A,135
00A4C:  MOVFF  12B,134
00A50:  MOVFF  136,01
00A54:  MOVFF  135,02
00A58:  MOVFF  134,03
00A5C:  BRA    0AC6
00A5E:  CLRF   00
00A60:  CLRF   01
00A62:  CLRF   02
00A64:  CLRF   03
00A66:  BRA    0AC6
00A68:  CLRF   x33
00A6A:  COMF   x34,F
00A6C:  COMF   x35,F
00A6E:  COMF   x36,F
00A70:  COMF   x33,F
00A72:  INCF   x33,F
00A74:  BNZ   0A80
00A76:  INCF   x34,F
00A78:  BNZ   0A80
00A7A:  INCF   x35,F
00A7C:  BNZ   0A80
00A7E:  INCF   x36,F
00A80:  BTFSC  x32.0
00A82:  BRA    08A8
00A84:  BTFSC  x32.1
00A86:  BRA    0930
00A88:  BTFSC  x32.2
00A8A:  BRA    099E
00A8C:  BRA    09F4
00A8E:  MOVF   FEF,W
00A90:  ADDWF  x34,F
00A92:  BNC   0A9E
00A94:  INCF   x35,F
00A96:  BNZ   0A9E
00A98:  INCF   x36,F
00A9A:  BTFSC  FD8.2
00A9C:  BSF    x30.0
00A9E:  MOVF   FED,F
00AA0:  MOVF   FEF,W
00AA2:  ADDWF  x35,F
00AA4:  BNC   0AAC
00AA6:  INCF   x36,F
00AA8:  BTFSC  FD8.2
00AAA:  BSF    x30.0
00AAC:  MOVF   FED,F
00AAE:  MOVF   FEF,W
00AB0:  BTFSC  FEF.7
00AB2:  BRA    0AB6
00AB4:  XORLW  80
00AB6:  ADDWF  x36,F
00AB8:  BTFSC  FD8.0
00ABA:  BSF    x30.0
00ABC:  BTFSC  x32.4
00ABE:  BRA    08B8
00AC0:  BTFSC  x32.5
00AC2:  BRA    0940
00AC4:  BRA    09AE
00AC6:  MOVLB  0
00AC8:  RETURN 0
*
00DAE:  MOVLW  8E
00DB0:  MOVWF  00
00DB2:  MOVLB  1
00DB4:  MOVF   x0D,W
00DB6:  SUBWF  00,F
00DB8:  MOVFF  10E,02
00DBC:  MOVFF  10F,01
00DC0:  BSF    02.7
00DC2:  MOVF   00,F
00DC4:  BZ    0DD8
00DC6:  BCF    FD8.0
00DC8:  MOVF   02,F
00DCA:  BNZ   0DD0
00DCC:  MOVF   01,F
00DCE:  BZ    0DD8
00DD0:  RRCF   02,F
00DD2:  RRCF   01,F
00DD4:  DECFSZ 00,F
00DD6:  BRA    0DC6
00DD8:  BTFSS  x0E.7
00DDA:  BRA    0DE6
00DDC:  COMF   01,F
00DDE:  COMF   02,F
00DE0:  INCF   01,F
00DE2:  BTFSC  FD8.2
00DE4:  INCF   02,F
00DE6:  MOVLB  0
00DE8:  GOTO   15A2 (RETURN)
.................... 
.................... #list
.................... 
.................... #include <stdio.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDIO
.................... #define _STDIO
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
*
004A8:  MOVFF  110,FEA
004AC:  MOVLB  1
004AE:  MOVFF  10F,FE9
004B2:  MOVFF  FEF,113
004B6:  MOVFF  112,FEA
004BA:  MOVFF  111,FE9
004BE:  MOVF   FEF,W
004C0:  SUBWF  x13,W
004C2:  BNZ   04F2
....................       if (*s1 == '\0')
004C4:  MOVFF  110,03
004C8:  MOVFF  10F,FE9
004CC:  MOVFF  03,FEA
004D0:  MOVF   FEF,F
004D2:  BNZ   04DA
....................          return(0);
004D4:  MOVLW  00
004D6:  MOVWF  01
004D8:  BRA    051C
004DA:  MOVFF  110,03
004DE:  MOVF   x0F,W
004E0:  INCF   x0F,F
004E2:  BTFSC  FD8.2
004E4:  INCF   x10,F
004E6:  INCF   x11,F
004E8:  BTFSC  FD8.2
004EA:  INCF   x12,F
004EC:  MOVLB  0
004EE:  BRA    04A8
004F0:  MOVLB  1
....................    return((*s1 < *s2) ? -1: 1);
004F2:  MOVFF  110,03
004F6:  MOVFF  10F,FE9
004FA:  MOVFF  03,FEA
004FE:  MOVFF  FEF,113
00502:  MOVFF  112,03
00506:  MOVFF  111,FE9
0050A:  MOVFF  03,FEA
0050E:  MOVF   FEF,W
00510:  SUBWF  x13,W
00512:  BC    0518
00514:  MOVLW  FF
00516:  BRA    051A
00518:  MOVLW  01
0051A:  MOVWF  01
0051C:  MOVLB  0
0051E:  RETURN 0
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    unsigned int8 n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
*
00548:  MOVFF  110,FEA
0054C:  MOVLB  1
0054E:  MOVFF  10F,FE9
00552:  MOVF   FEF,F
00554:  BZ    05BC
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
00556:  MOVFF  110,114
0055A:  MOVFF  10F,113
0055E:  MOVFF  112,116
00562:  MOVFF  111,115
00566:  MOVFF  116,FEA
0056A:  MOVFF  115,FE9
0056E:  MOVF   FEF,F
00570:  BZ    059A
00572:  MOVFF  114,FEA
00576:  MOVFF  113,FE9
0057A:  MOVFF  FEF,117
0057E:  MOVFF  116,FEA
00582:  MOVFF  115,FE9
00586:  MOVF   FEF,W
00588:  SUBWF  x17,W
0058A:  BNZ   059A
0058C:  INCF   x13,F
0058E:  BTFSC  FD8.2
00590:  INCF   x14,F
00592:  INCF   x15,F
00594:  BTFSC  FD8.2
00596:  INCF   x16,F
00598:  BRA    0566
.................... 
....................       if (*t == '\0')
0059A:  MOVFF  116,FEA
0059E:  MOVFF  115,FE9
005A2:  MOVF   FEF,F
005A4:  BNZ   05B0
....................          return s1;
005A6:  MOVFF  10F,01
005AA:  MOVFF  110,02
005AE:  BRA    05C2
....................       ++s1;
005B0:  INCF   x0F,F
005B2:  BTFSC  FD8.2
005B4:  INCF   x10,F
....................       #ifdef FASTER_BUT_MORE_ROM
005B6:  MOVLB  0
005B8:  BRA    0548
005BA:  MOVLB  1
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
005BC:  MOVLW  00
005BE:  MOVWF  01
005C0:  MOVWF  02
005C2:  MOVLB  0
005C4:  GOTO   14BC (RETURN)
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
*
00448:  MOVFF  10E,110
0044C:  MOVFF  10D,10F
00450:  MOVFF  110,FEA
00454:  MOVLB  1
00456:  MOVFF  10F,FE9
0045A:  MOVF   FEF,F
0045C:  BZ    049C
....................       if (*p >= 'a' && *p <='z')
0045E:  MOVFF  110,03
00462:  MOVFF  10F,FE9
00466:  MOVFF  03,FEA
0046A:  MOVF   FEF,W
0046C:  SUBLW  60
0046E:  BC    0490
00470:  MOVFF  110,FEA
00474:  MOVFF  10F,FE9
00478:  MOVF   FEF,W
0047A:  SUBLW  7A
0047C:  BNC   0490
....................          *p -= 'a' - 'A';
0047E:  MOVFF  110,03
00482:  MOVFF  10F,FE9
00486:  MOVFF  03,FEA
0048A:  MOVLW  20
0048C:  SUBWF  FEF,W
0048E:  MOVWF  FEF
00490:  INCF   x0F,F
00492:  BTFSC  FD8.2
00494:  INCF   x10,F
00496:  MOVLB  0
00498:  BRA    0450
0049A:  MOVLB  1
....................    return(s);
0049C:  MOVFF  10D,01
004A0:  MOVFF  10E,02
004A4:  MOVLB  0
004A6:  RETURN 0
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... #ifndef getc
.................... #define getc getch
.................... #define getchar getch
.................... #define puts(s) {printf(s); putchar(13); putchar(10);}
.................... #define putc putchar
.................... #endif
.................... /* maps error number to an error message. Writes a sequence of characters to
.................... stderr stream thus: if s is not null then string pointed to by s follwed by
.................... a colon (:) and a space and the appropriate error message returned by strerror
.................... function with argument errno
.................... 
.................... Returns: no value
.................... */
.................... 
.................... #ifdef _ERRNO
.................... void perror(char *s)
.................... {
....................   if(s)
....................   fprintf(STDERR,"%s: ",s);
....................   fprintf(STDERR,"%s\r\n",strerror(errno));
.................... }
.................... #endif
.................... #endif
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... #include <ctype.h>
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    unsigned int8 n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... #include <stdlib.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... #ifndef _STDLIB
.................... #define _STDLIB
.................... 
.................... //---------------------------------------------------------------------------
.................... // Definitions and types
.................... //---------------------------------------------------------------------------
.................... 
.................... #ifndef RAND_MAX
.................... #define RAND_MAX  32767    // The value of which is the maximum value
....................                            // ... returned by the rand function
.................... #endif
.................... 
.................... 
.................... #IF (sizeof(int16*)>1)
.................... #DEFINE LONG_POINTERS 1
.................... #ELSE 
.................... #DEFINE LONG_POINTERS 0
.................... #ENDIF
.................... 
.................... typedef struct {
....................    signed int quot;
....................    signed int rem;
.................... } div_t;
.................... 
.................... typedef struct {
....................    signed long quot;
....................    signed long rem;
.................... } ldiv_t;
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // String conversion functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Standard template: signed int  atoi(char * s)
....................  * converts the initial portion of the string s to a signed int
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed int atoi(char *s);
.................... 
.................... /* Syntax: signed int32  atoi32(char * s)
....................    converts the initial portion of the string s to a signed int32
....................    returns the converted value if any, 0 otherwise*/
.................... #if (sizeof(long)==4)
....................  #define atoi32(s) atol(s)
.................... #else 
....................  signed int32 atoi32(char *s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... /* Syntax: signed int48  atoi48(char * s)
....................    converts the initial portion of the string s to a signed int48
....................    returns the converted value if any, 0 otherwise*/
....................    
.................... signed int48 atoi48(char *s);
.................... 
.................... /* Syntax: signed int64  atoi64(char * s)
....................    converts the initial portion of the string s to a signed int64
....................    returns the converted value if any, 0 otherwise*/
.................... signed int64 atoi64(char *s);
.................... #endif
.................... 
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s)
....................    converts the signed int32 to a string and
....................    returns the converted value if any, 0 otherwise*/
.................... char * itoa(signed int32 num, unsigned int base, char * s);
.................... 
.................... /* Standard template: signed int16  atol(char * s)
....................  * converts the initial portion of the string s to a signed int16
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed long atol(char *s);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base  to a signed long.
....................  * Returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... signed long strtol(char *s,char *endptr, signed int base);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base to a unsigned long.
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... unsigned long strtoul(char *s,char *endptr, signed int base);
.................... 
.................... /* Standart template: float strtof(char * s,char *endptr)
....................                       float48 strtof48(char *s,char *endptr);
....................                       float64 strtod(char *s,char *endptr);
....................  * converts the initial portion of the string s to a float32, float48 or float64,
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null                   
.................... */
.................... float strtof(char *s,char **endptr);
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s,char **endptr);
.................... float64 strtod(char *s,char **endptr);
.................... #else
.................... //provided for compatibility
.................... #define strtof48(s, e) strtof(s, e)
.................... #define strtod(s, e) strtof(s, e)
.................... #endif
.................... 
.................... /* Standard template: float32 atof(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof(s)   strtof(s, (char*)0)
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... 
.................... /* Standard template: float48 atof48(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof48(s) strtof48(s, 0)
.................... 
.................... /* Standard template: float64 atof64(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof64(s) strtod(s, 0)
.................... #endif
.................... 
.................... /* Standard template: float32 atoe(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  * also handles E format numbers
....................  */
.................... #if !defined(__PCD__)
.................... float atoe(char * s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s);
.................... #endif
.................... 
.................... //---------------------------------------------------------------------------
.................... // Pseudo-random sequence generation functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The rand function computes a sequence of pseudo-random integers in
....................  * the range 0 to RAND_MAX
....................  *
....................  * Parameters:
....................  *       (none)
....................  *
....................  * Returns:
....................  *       The pseudo-random integer
....................  */
.................... unsigned int16 rand(void);
.................... 
.................... /* The srand function uses the argument as a seed for a new sequence of
....................  * pseudo-random numbers to be returned by subsequent calls to rand.
....................  *
....................  * Parameters:
....................  *       [in] seed: The seed value to start from. You might need to pass
....................  *
....................  * Returns:
....................  *       (none)
....................  *
....................  * Remarks
....................  *          The srand function sets the starting point for generating
....................  *       a series of pseudorandom integers. To reinitialize the
....................  *       generator, use 1 as the seed argument. Any other value for
....................  *       seed sets the generator to a random starting point. rand
....................  *       retrieves the pseudorandom numbers that are generated.
....................  *       Calling rand before any call to srand generates the same
....................  *       sequence as calling srand with seed passed as 1.
....................  *          Usually, you need to pass a time here from outer source
....................  *       so that the numbers will be different every time you run.
....................  */
.................... void srand(unsigned int32 seed);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Memory management functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Comming soon
.................... 
.................... //---------------------------------------------------------------------------
.................... // Communication with the environment
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The function returns 0 always
....................  */
.................... signed int8 system(char *string);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Performs a binary search of a sorted array..
....................  *
....................  * Parameters:
....................  *       [in] key: Object to search for
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed
....................  *       to by base. If key is not found, the function returns NULL. If the
....................  *       array is not in order or contains duplicate records with identical keys,
....................  *       the result is unpredictable.
....................  */
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents
....................  * of the array are sorted into ascending order according to a comparison
....................  * function pointed to by compar.
....................  *
....................  * Parameters:
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       (none)
....................  */
.................... //void *qsort(const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... //---------------------------------------------------------------------------
.................... // Integer arithmetic functions
.................... //---------------------------------------------------------------------------
.................... 
.................... #define labs abs
.................... 
.................... div_t div(signed int numer, signed int denom);
.................... ldiv_t ldiv(signed long numer, signed long denom);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte character functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte string functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // Internal implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... #include <ctype.h>
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    unsigned int8 n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... div_t div(signed int numer, signed int denom)
.................... {
....................    div_t val;
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... ldiv_t ldiv(signed long numer, signed long denom)
.................... {
....................    ldiv_t val;
.................... 
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s)
.................... {
....................    float32 pow10 = 1.0;
....................    float32 result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float32 exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if !defined(__PCD__)
.................... float atoe(char * s)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... signed int atoi(char *s)
.................... {
....................    signed int result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    // Omit all preceeding alpha characters
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
.................... 
....................       // Check for hexa number
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];
....................             c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (sign == 1 && base == 10)
....................        result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed long atol(char *s)
.................... {
....................    signed long result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... /* A fast routine to multiply by 10
....................  */
.................... signed int32 mult_with10(int32 num)
.................... {
....................    return ( (num << 1) + (num << 3) );
.................... }
.................... 
.................... #if sizeof(long)==2
.................... signed int32 atoi32(char *s)
.................... {
....................    signed int32 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... 
.................... signed int48 atoi48(char *s)
.................... {
....................    signed int48 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed int64 atoi64(char *s)
.................... {
....................    signed int64 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... char * itoa(signed int32 num, unsigned int base, char * s)
.................... {
....................      unsigned int32 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #if defined(__PCD__)
.................... 
.................... char * itoa(signed int48 num, unsigned int base, char * s)
.................... {
....................      unsigned int48 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... char * itoa(signed int64 num, unsigned int base, char * s)
.................... {
....................      unsigned int64 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
....................      
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;        
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
....................             
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #endif
.................... 
.................... float strtof(char *s, char **endptr)
*
00ACA:  MOVLB  1
00ACC:  CLRF   x1C
00ACE:  CLRF   x1B
00AD0:  CLRF   x1A
00AD2:  MOVLW  7F
00AD4:  MOVWF  x19
00AD6:  CLRF   x20
00AD8:  CLRF   x1F
00ADA:  CLRF   x1E
00ADC:  CLRF   x1D
00ADE:  BSF    x21.0
00AE0:  BCF    x21.1
00AE2:  BCF    x21.2
00AE4:  CLRF   x23
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
00AE6:  MOVF   x15,W
00AE8:  IORWF  x16,W
00AEA:  BNZ   0AF6
....................       return 0;
00AEC:  CLRF   00
00AEE:  CLRF   01
00AF0:  CLRF   02
00AF2:  CLRF   03
00AF4:  BRA    0D10
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
00AF6:  MOVF   x23,W
00AF8:  INCF   x23,F
00AFA:  ADDWF  x15,W
00AFC:  MOVWF  FE9
00AFE:  MOVLW  00
00B00:  ADDWFC x16,W
00B02:  MOVWF  FEA
00B04:  MOVFF  FEF,122
00B08:  MOVF   x22,F
00B0A:  BTFSC  FD8.2
00B0C:  BRA    0C96
....................    {
....................       if (skip && !isspace(c))
00B0E:  BTFSS  x21.0
00B10:  BRA    0B30
00B12:  MOVF   x22,W
00B14:  SUBLW  20
00B16:  BZ    0B30
....................       {
....................          skip = 0;
00B18:  BCF    x21.0
....................          if (c == '+')
00B1A:  MOVF   x22,W
00B1C:  SUBLW  2B
00B1E:  BNZ   0B26
....................          {
....................             sign = 0;
00B20:  BCF    x21.1
....................             continue;
00B22:  BRA    0C7E
....................          }            
00B24:  BRA    0B30
....................          else if (c == '-')
00B26:  MOVF   x22,W
00B28:  SUBLW  2D
00B2A:  BNZ   0B30
....................          {
....................             sign = 1;
00B2C:  BSF    x21.1
....................             continue;
00B2E:  BRA    0C7E
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
00B30:  BTFSC  x21.0
00B32:  BRA    0B42
00B34:  MOVF   x22,W
00B36:  SUBLW  2E
00B38:  BNZ   0B42
00B3A:  BTFSC  x21.2
00B3C:  BRA    0B42
....................          point = 1;
00B3E:  BSF    x21.2
00B40:  BRA    0C7E
....................       else if (!skip && isdigit(c))
00B42:  BTFSC  x21.0
00B44:  BRA    0C78
00B46:  MOVF   x22,W
00B48:  SUBLW  2F
00B4A:  BTFSC  FD8.0
00B4C:  BRA    0C78
00B4E:  MOVF   x22,W
00B50:  SUBLW  39
00B52:  BTFSS  FD8.0
00B54:  BRA    0C78
....................       {
....................          c -= '0';
00B56:  MOVLW  30
00B58:  SUBWF  x22,F
....................          if (point)
00B5A:  BTFSS  x21.2
00B5C:  BRA    0C04
....................          {
....................             pow10 = pow10 * 10.0;
00B5E:  MOVFF  11C,127
00B62:  MOVFF  11B,126
00B66:  MOVFF  11A,125
00B6A:  MOVFF  119,124
00B6E:  CLRF   x2B
00B70:  CLRF   x2A
00B72:  MOVLW  20
00B74:  MOVWF  x29
00B76:  MOVLW  82
00B78:  MOVWF  x28
00B7A:  MOVLB  0
00B7C:  RCALL  05C8
00B7E:  MOVFF  03,11C
00B82:  MOVFF  02,11B
00B86:  MOVFF  01,11A
00B8A:  MOVFF  00,119
....................             result += (float)c / pow10;   
00B8E:  MOVLB  1
00B90:  CLRF   x29
00B92:  MOVFF  122,128
00B96:  MOVLB  0
00B98:  RCALL  06BE
00B9A:  MOVFF  03,127
00B9E:  MOVFF  02,126
00BA2:  MOVFF  01,125
00BA6:  MOVFF  00,124
00BAA:  MOVFF  03,12B
00BAE:  MOVFF  02,12A
00BB2:  MOVFF  01,129
00BB6:  MOVFF  00,128
00BBA:  MOVFF  11C,12F
00BBE:  MOVFF  11B,12E
00BC2:  MOVFF  11A,12D
00BC6:  MOVFF  119,12C
00BCA:  RCALL  06F4
00BCC:  BCF    FD8.1
00BCE:  MOVFF  120,12B
00BD2:  MOVFF  11F,12A
00BD6:  MOVFF  11E,129
00BDA:  MOVFF  11D,128
00BDE:  MOVFF  03,12F
00BE2:  MOVFF  02,12E
00BE6:  MOVFF  01,12D
00BEA:  MOVFF  00,12C
00BEE:  RCALL  0852
00BF0:  MOVFF  03,120
00BF4:  MOVFF  02,11F
00BF8:  MOVFF  01,11E
00BFC:  MOVFF  00,11D
....................          }
00C00:  BRA    0C74
00C02:  MOVLB  1
....................          else
....................          {
....................             result = 10.0 * result + (float)c;
00C04:  CLRF   x27
00C06:  CLRF   x26
00C08:  MOVLW  20
00C0A:  MOVWF  x25
00C0C:  MOVLW  82
00C0E:  MOVWF  x24
00C10:  MOVFF  120,12B
00C14:  MOVFF  11F,12A
00C18:  MOVFF  11E,129
00C1C:  MOVFF  11D,128
00C20:  MOVLB  0
00C22:  RCALL  05C8
00C24:  MOVFF  03,127
00C28:  MOVFF  02,126
00C2C:  MOVFF  01,125
00C30:  MOVFF  00,124
00C34:  MOVLB  1
00C36:  CLRF   x29
00C38:  MOVFF  122,128
00C3C:  MOVLB  0
00C3E:  RCALL  06BE
00C40:  BCF    FD8.1
00C42:  MOVFF  127,12B
00C46:  MOVFF  126,12A
00C4A:  MOVFF  125,129
00C4E:  MOVFF  124,128
00C52:  MOVFF  03,12F
00C56:  MOVFF  02,12E
00C5A:  MOVFF  01,12D
00C5E:  MOVFF  00,12C
00C62:  RCALL  0852
00C64:  MOVFF  03,120
00C68:  MOVFF  02,11F
00C6C:  MOVFF  01,11E
00C70:  MOVFF  00,11D
....................          }
....................       }
00C74:  BRA    0C80
00C76:  MOVLB  1
....................       else if (!skip)
00C78:  BTFSC  x21.0
00C7A:  BRA    0C7E
....................          break;
00C7C:  BRA    0C96
00C7E:  MOVLB  0
00C80:  MOVLB  1
00C82:  MOVF   x23,W
00C84:  INCF   x23,F
00C86:  ADDWF  x15,W
00C88:  MOVWF  FE9
00C8A:  MOVLW  00
00C8C:  ADDWFC x16,W
00C8E:  MOVWF  FEA
00C90:  MOVFF  FEF,122
00C94:  BRA    0B08
....................    }
.................... 
....................    if (sign)
00C96:  BTFSS  x21.1
00C98:  BRA    0CCC
....................       result = -1*result;
00C9A:  CLRF   x27
00C9C:  CLRF   x26
00C9E:  MOVLW  80
00CA0:  MOVWF  x25
00CA2:  MOVLW  7F
00CA4:  MOVWF  x24
00CA6:  MOVFF  120,12B
00CAA:  MOVFF  11F,12A
00CAE:  MOVFF  11E,129
00CB2:  MOVFF  11D,128
00CB6:  MOVLB  0
00CB8:  RCALL  05C8
00CBA:  MOVFF  03,120
00CBE:  MOVFF  02,11F
00CC2:  MOVFF  01,11E
00CC6:  MOVFF  00,11D
00CCA:  MOVLB  1
....................       
....................    if(endptr)
00CCC:  MOVF   x17,W
00CCE:  IORWF  x18,W
00CD0:  BZ    0D00
....................    {
....................       if (ptr) {
00CD2:  MOVF   x23,F
00CD4:  BZ    0CEE
....................          ptr--;
00CD6:  DECF   x23,F
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
00CD8:  MOVFF  118,FEA
00CDC:  MOVFF  117,FE9
00CE0:  MOVF   x23,W
00CE2:  ADDWF  x15,W
00CE4:  MOVWF  FEF
00CE6:  MOVLW  00
00CE8:  ADDWFC x16,W
00CEA:  MOVWF  FEC
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
00CEC:  BRA    0D00
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
00CEE:  MOVFF  118,FEA
00CF2:  MOVFF  117,FE9
00CF6:  MOVFF  116,FEC
00CFA:  MOVF   FED,F
00CFC:  MOVFF  115,FEF
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
00D00:  MOVFF  11D,00
00D04:  MOVFF  11E,01
00D08:  MOVFF  11F,02
00D0C:  MOVFF  120,03
00D10:  MOVLB  0
00D12:  GOTO   0D8A (RETURN)
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s, char **endptr)
.................... {
....................    float48 pow10 = 1.0;
....................    float48 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float48)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float48)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... float64 strtod(char *s, char **endptr)
.................... {
....................    float64 pow10 = 1.0;
....................    float64 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float64)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float64)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... unsigned long strtoul(char *s, char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    unsigned long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base
....................    goto StrtoulGO;
.................... 
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(; sd!=0; )
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtoulGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................          }
....................    return 0;
....................    }
....................    if (endptr)
....................    {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................          #ELSE
....................          *((char *)endptr)=sc; 
....................          #ENDIF
....................    }
....................    return x;
.................... }
.................... 
.................... 
.................... signed long strtol(char *s,char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    signed long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if (base <0 || base ==1|| base >36) // invalid base
....................    goto StrtolGO;
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
.................... 
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(;sd!=0;)
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtolGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................       }
....................    return 0;
....................    }
....................    if(sign=='-')
....................       x  =-x;
....................    if (endptr)
....................    {
....................         #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................         #ELSE
....................         *((char *)endptr)=sc;
....................         #ENDIF
....................    }
....................    return x;
.................... }
.................... 
.................... signed int8 system(char *string)
.................... {
....................    return 0;
.................... }
.................... 
.................... size_t mblen(char *s,size_t n)
.................... {
....................    return strlen(s);
.................... }
.................... 
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n)
.................... {
....................    *pwc=*s;
....................    return 1;
.................... }
.................... 
.................... int8 wctomb(char *s,wchar_t wchar)
.................... {
....................    *s=wchar;
....................    return 1;
.................... }
.................... 
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n)
.................... {
....................    strncpy((char *)pwcs,s,n);
....................    return strlen((char *)pwcs);
.................... }
.................... 
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n)
.................... {
....................    strncpy(s,(char *)pwcs,n);
....................    return strlen(s);
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // The random number implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... unsigned int32 _Randseed;
.................... 
.................... unsigned int16 rand(void)
.................... {
....................    _Randseed = _Randseed * 1103515245 + 12345;
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX);
.................... }
.................... 
.................... void srand(unsigned int32 seed)
.................... {
....................    _Randseed = seed;
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #if !defined(__PCD__)
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2); 
.................... #else 
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2); 
.................... #endif
.................... 
.................... 
.................... 
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) {
....................    unsigned int m,j,i,l;
....................    int1 done;
....................    unsigned int8 t[16];
.................... 
....................    m = qitems/2;
....................    while( m > 0 ) {
....................      for(j=0; j<(qitems-m); ++j) {
....................         i = j;
....................         do
....................         {
....................            done=1;
....................            l = i+m;
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) {
....................               memcpy(t, qdata+i*qsize, qsize);
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize);
....................               memcpy(qdata+l*qsize, t, qsize);
....................               if(m <= i)
....................                 i -= m;
....................                 done = 0;
....................            }
....................         } while(!done);
....................      }
....................      m = m/2;
....................    }
.................... }
.................... 
.................... 
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp)
.................... {
....................    char *p, *q;
....................    size_t n;
....................    size_t pivot;
....................    signed int val;
.................... 
....................    p = base;
....................    n = num;
.................... 
....................    while (n > 0)
....................    {
....................       pivot = n >> 1;
....................       q = p + width * pivot;
.................... 
....................       val = (*cmp)(key, q);
.................... 
....................       if (val < 0)
....................          n = pivot;
....................       else if (val == 0)
....................          return ((char *)q);
....................       else {
....................          p = q + width;
....................          n -= pivot + 1;
....................       }
....................    }
.................... 
....................    return NULL;      // There's no match
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... #fuses NOMCLR RSTOSC_HFINTRC_64MHZ CLKOUT PUT
....................  
.................... #use delay(internal = 32MHZ, clock_out)
*
00334:  MOVLW  02
00336:  MOVLB  1
00338:  SUBWF  x11,F
0033A:  BNC   0354
0033C:  MOVLW  01
0033E:  MOVWF  FEA
00340:  MOVLW  11
00342:  MOVWF  FE9
00344:  MOVF   FEF,W
00346:  BZ    0354
00348:  BRA    0350
0034A:  BRA    034C
0034C:  BRA    034E
0034E:  NOP   
00350:  DECFSZ FEF,F
00352:  BRA    034A
00354:  MOVLB  0
00356:  GOTO   0370 (RETURN)
*
00520:  MOVLW  01
00522:  MOVWF  FEA
00524:  MOVLW  0D
00526:  MOVWF  FE9
00528:  MOVF   FEF,W
0052A:  BZ    0546
0052C:  MOVLW  0A
0052E:  MOVWF  01
00530:  CLRF   00
00532:  DECFSZ 00,F
00534:  BRA    0532
00536:  DECFSZ 01,F
00538:  BRA    0530
0053A:  MOVLW  5F
0053C:  MOVWF  00
0053E:  DECFSZ 00,F
00540:  BRA    053E
00542:  DECFSZ FEF,F
00544:  BRA    052C
00546:  RETURN 0
.................... #define Forever 1
.................... 
.................... //defining pins for FTDI and PWM
.................... #pin_select PWM4=PIN_C4
.................... #pin_select PWM4=PIN_C5
.................... #pin_select U1TX=PIN_C6
.................... #pin_select U1RX=PIN_C7
.................... //RS232 has same values with configuration of Putty
.................... #use RS232(uart1, baud=9600, BITS = 8, STOP = 2, Parity = N, ERRORS, STREAM = Serial_Stream)
*
000C0:  MOVLB  E
000C2:  BTFSS  xCD.5
000C4:  BRA    00C2
000C6:  MOVFF  F9D,22
000CA:  MOVFF  F99,01
000CE:  BTFSS  22.1
000D0:  BRA    00D6
000D2:  BCF    F9D.4
000D4:  BSF    F9D.4
000D6:  MOVLB  0
000D8:  RETURN 0
*
0035A:  MOVLB  E
0035C:  BTFSS  xCD.4
0035E:  BRA    035C
00360:  MOVLB  1
00362:  MOVF   x10,W
00364:  MOVWF  F9A
00366:  BTFSS  F9E.1
00368:  BRA    0366
0036A:  CLRF   x11
0036C:  MOVLB  0
0036E:  BRA    0334
00370:  RETURN 0
.................... 
.................... //Buffer Definitions
.................... #define RS232BUFFSIZE 32
.................... char RS232_buffer[RS232BUFFSIZE];
.................... int RS232_next_in = 0;    //input pointer
.................... int RS232_next_out = 0;   //output pointer
.................... char brightness[20];      //character to get string of numbers for brightness percentage
.................... 
.................... //structure
.................... struct Structure_1 
.................... {
....................    int unused_A;          //All A pins not used
....................    int unused_B;          //All B pins not used
....................    int1 LED1;             //LEDs
....................    int1 LED2;
....................    int1 LED3;
....................    int1 LED4;
....................    int unused_C:2;        //2 unused C pins
....................    int1 TXpin;            //Transmit Pin to FTDI
....................    int1 RXpin;            //Receive Pin from FTDI
.................... } Port, Direction, Latch; //setting variable names
.................... 
.................... //setting variables to SFR addresses
.................... #byte Port = 0xF8D       /* PORTA register in SFR */
.................... #byte Latch = 0xF83      /* LATA register in SFR  */
.................... #byte Direction = 0xF88  /* TRISA register in SFR */
.................... 
.................... #int_RDA //receive data available, next function is interrupt
.................... void RS232_Interrupt_Routine()  //RS232 Receive Data Available
*
000DA:  MOVLB  0
.................... {  
....................    RS232_buffer[RS232_next_in] = fgetc(Serial_Stream);     //get character and place in buffer
000DC:  CLRF   03
000DE:  MOVF   43,W
000E0:  ADDLW  23
000E2:  MOVWF  FE9
000E4:  MOVLW  00
000E6:  ADDWFC 03,W
000E8:  MOVWF  FEA
000EA:  MOVFF  FEA,13B
000EE:  MOVFF  FE9,13A
000F2:  RCALL  00C0
000F4:  MOVFF  13B,FEA
000F8:  MOVFF  13A,FE9
000FC:  MOVFF  01,FEF
....................    if ((RS232_next_in+1) % RS232BUFFSIZE != RS232_next_out)//if not last, keep adding
00100:  MOVLW  01
00102:  ADDWF  43,W
00104:  ANDLW  1F
00106:  SUBWF  44,W
00108:  BZ    0112
....................    {
....................       RS232_next_in = (RS232_next_in+1)%RS232BUFFSIZE;
0010A:  MOVLW  01
0010C:  ADDWF  43,W
0010E:  ANDLW  1F
00110:  MOVWF  43
....................    }
00112:  MOVLB  E
00114:  BCF    xCD.5
00116:  MOVLB  0
00118:  GOTO   006A
.................... }
.................... 
.................... //function that returns a string without leading spaces
.................... char GetCom (char * command_string) 
*
003C0:  CLRF   x7F
.................... {
....................    int length = 0;
....................    char c;
....................    RS232_next_out = 0;
003C2:  CLRF   44
....................    
....................    do //ignoring leading spaces
....................    {
....................       c = RS232_buffer[RS232_next_out]; //getting character from buffer
003C4:  CLRF   03
003C6:  MOVF   44,W
003C8:  ADDLW  23
003CA:  MOVWF  FE9
003CC:  MOVLW  00
003CE:  ADDWFC 03,W
003D0:  MOVWF  FEA
003D2:  MOVFF  FEF,80
....................       RS232_next_out = (RS232_next_out+1)%RS232BUFFSIZE;
003D6:  MOVLW  01
003D8:  ADDWF  44,W
003DA:  ANDLW  1F
003DC:  MOVWF  44
....................    } while (c == ' ');
003DE:  MOVF   x80,W
003E0:  SUBLW  20
003E2:  BZ    03C4
....................    
....................    //Entering non-space character
....................    command_string[length++] = c;
003E4:  MOVF   x7F,W
003E6:  INCF   x7F,F
003E8:  ADDWF  x7D,W
003EA:  MOVWF  FE9
003EC:  MOVLW  00
003EE:  ADDWFC x7E,W
003F0:  MOVWF  FEA
003F2:  MOVFF  80,FEF
....................    
....................    //getting rest of command string
....................    while((c != 13) && (length<20))
003F6:  MOVF   x80,W
003F8:  SUBLW  0D
003FA:  BZ    0430
003FC:  MOVF   x7F,W
003FE:  SUBLW  13
00400:  BNC   0430
....................    {
....................       c = RS232_buffer[RS232_next_out];
00402:  CLRF   03
00404:  MOVF   44,W
00406:  ADDLW  23
00408:  MOVWF  FE9
0040A:  MOVLW  00
0040C:  ADDWFC 03,W
0040E:  MOVWF  FEA
00410:  MOVFF  FEF,80
....................       RS232_next_out = (RS232_next_out+1)%RS232BUFFSIZE;
00414:  MOVLW  01
00416:  ADDWF  44,W
00418:  ANDLW  1F
0041A:  MOVWF  44
....................       command_string[length++] = c;
0041C:  MOVF   x7F,W
0041E:  INCF   x7F,F
00420:  ADDWF  x7D,W
00422:  MOVWF  FE9
00424:  MOVLW  00
00426:  ADDWFC x7E,W
00428:  MOVWF  FEA
0042A:  MOVFF  80,FEF
0042E:  BRA    03F6
....................    }
....................    command_string[--length] = '\0';
00430:  DECF   x7F,F
00432:  MOVF   x7F,W
00434:  ADDWF  x7D,W
00436:  MOVWF  FE9
00438:  MOVLW  00
0043A:  ADDWFC x7E,W
0043C:  MOVWF  FEA
0043E:  CLRF   FEF
....................    return command_string;
00440:  MOVFF  7D,01
00444:  GOTO   1880 (RETURN)
.................... }//end getcom
.................... 
.................... //function to only get the numbers from brightness[value] and convert it into a float
.................... float GetBrightness(char * brightness_input)
*
00D16:  MOVLB  1
00D18:  CLRF   x10
.................... {
....................    int i;
....................    int length = 0;
....................    float level;
....................    
....................    //only takes number out of string
....................    while(length <= 20)
00D1A:  MOVF   x10,W
00D1C:  SUBLW  14
00D1E:  BNC   0D7C
....................    {
....................       if((brightness_input[length] >= '0') && (brightness_input[length] <= '9') || (brightness_input == '.'))
00D20:  MOVF   x10,W
00D22:  ADDWF  x0D,W
00D24:  MOVWF  FE9
00D26:  MOVLW  00
00D28:  ADDWFC x0E,W
00D2A:  MOVWF  FEA
00D2C:  MOVF   FEF,W
00D2E:  SUBLW  2F
00D30:  BC    0D44
00D32:  MOVF   x10,W
00D34:  ADDWF  x0D,W
00D36:  MOVWF  FE9
00D38:  MOVLW  00
00D3A:  ADDWFC x0E,W
00D3C:  MOVWF  FEA
00D3E:  MOVF   FEF,W
00D40:  SUBLW  39
00D42:  BC    0D4E
00D44:  MOVF   x0D,W
00D46:  SUBLW  2E
00D48:  BNZ   0D78
00D4A:  MOVF   x0E,F
00D4C:  BNZ   0D78
....................       {
....................          brightness[i] = brightness_input[length];
00D4E:  CLRF   03
00D50:  MOVF   x0F,W
00D52:  ADDLW  45
00D54:  MOVWF  01
00D56:  MOVLW  00
00D58:  ADDWFC 03,F
00D5A:  MOVF   x10,W
00D5C:  ADDWF  x0D,W
00D5E:  MOVWF  FE9
00D60:  MOVLW  00
00D62:  ADDWFC x0E,W
00D64:  MOVWF  FEA
00D66:  MOVFF  FEF,117
00D6A:  MOVFF  03,FEA
00D6E:  MOVFF  01,FE9
00D72:  MOVFF  117,FEF
....................          i++;
00D76:  INCF   x0F,F
....................       }
....................       length++;
00D78:  INCF   x10,F
00D7A:  BRA    0D1A
....................    }
....................    level = atof(brightness);  //converts string to float
00D7C:  CLRF   x16
00D7E:  MOVLW  45
00D80:  MOVWF  x15
00D82:  CLRF   x18
00D84:  CLRF   x17
00D86:  MOVLB  0
00D88:  BRA    0ACA
00D8A:  MOVFF  03,114
00D8E:  MOVFF  02,113
00D92:  MOVFF  01,112
00D96:  MOVFF  00,111
....................    return level;              //return float back to receive commmand 
00D9A:  MOVFF  111,00
00D9E:  MOVFF  112,01
00DA2:  MOVFF  113,02
00DA6:  MOVFF  114,03
00DAA:  GOTO   14F6 (RETURN)
.................... } //end adjusting brightness level
.................... 
.................... void Cmd_Receive(char * string)
*
00FE6:  CLRF   x06
.................... {
....................    //string functions used:                                          
....................    //strcmp compares 2 strings and if they are identical it returns 0
....................    //strupr converts a given string to uppercase                     
....................    //strstr uses a main string to find a desired string we want inside that main string
....................    
....................    //string definitions to be compared
....................    char LED1ON[] = "LED 1 ON";
*
00DEC:  MOVLW  4C
00DEE:  MOVWF  x7F
00DF0:  MOVLW  45
00DF2:  MOVWF  x80
00DF4:  MOVLW  44
00DF6:  MOVWF  x81
00DF8:  MOVLW  20
00DFA:  MOVWF  x82
00DFC:  MOVLW  31
00DFE:  MOVWF  x83
00E00:  MOVLW  20
00E02:  MOVWF  x84
00E04:  MOVLW  4F
00E06:  MOVWF  x85
00E08:  MOVLW  4E
00E0A:  MOVWF  x86
00E0C:  CLRF   x87
....................    char LED1OFF[] = "LED 1 OFF";
00E0E:  MOVLW  4C
00E10:  MOVWF  x88
00E12:  MOVLW  45
00E14:  MOVWF  x89
00E16:  MOVLW  44
00E18:  MOVWF  x8A
00E1A:  MOVLW  20
00E1C:  MOVWF  x8B
00E1E:  MOVLW  31
00E20:  MOVWF  x8C
00E22:  MOVLW  20
00E24:  MOVWF  x8D
00E26:  MOVLW  4F
00E28:  MOVWF  x8E
00E2A:  MOVLW  46
00E2C:  MOVWF  x8F
00E2E:  MOVWF  x90
00E30:  CLRF   x91
....................    char LED2ON[] = "LED 2 ON";
00E32:  MOVLW  4C
00E34:  MOVWF  x92
00E36:  MOVLW  45
00E38:  MOVWF  x93
00E3A:  MOVLW  44
00E3C:  MOVWF  x94
00E3E:  MOVLW  20
00E40:  MOVWF  x95
00E42:  MOVLW  32
00E44:  MOVWF  x96
00E46:  MOVLW  20
00E48:  MOVWF  x97
00E4A:  MOVLW  4F
00E4C:  MOVWF  x98
00E4E:  MOVLW  4E
00E50:  MOVWF  x99
00E52:  CLRF   x9A
....................    char LED2OFF[] = "LED 2 OFF";
00E54:  MOVLW  4C
00E56:  MOVWF  x9B
00E58:  MOVLW  45
00E5A:  MOVWF  x9C
00E5C:  MOVLW  44
00E5E:  MOVWF  x9D
00E60:  MOVLW  20
00E62:  MOVWF  x9E
00E64:  MOVLW  32
00E66:  MOVWF  x9F
00E68:  MOVLW  20
00E6A:  MOVWF  xA0
00E6C:  MOVLW  4F
00E6E:  MOVWF  xA1
00E70:  MOVLW  46
00E72:  MOVWF  xA2
00E74:  MOVWF  xA3
00E76:  CLRF   xA4
....................    char LED3ON[] = "LED 3 ON";
00E78:  MOVLW  4C
00E7A:  MOVWF  xA5
00E7C:  MOVLW  45
00E7E:  MOVWF  xA6
00E80:  MOVLW  44
00E82:  MOVWF  xA7
00E84:  MOVLW  20
00E86:  MOVWF  xA8
00E88:  MOVLW  33
00E8A:  MOVWF  xA9
00E8C:  MOVLW  20
00E8E:  MOVWF  xAA
00E90:  MOVLW  4F
00E92:  MOVWF  xAB
00E94:  MOVLW  4E
00E96:  MOVWF  xAC
00E98:  CLRF   xAD
....................    char LED3OFF[] = "LED 3 OFF";
00E9A:  MOVLW  4C
00E9C:  MOVWF  xAE
00E9E:  MOVLW  45
00EA0:  MOVWF  xAF
00EA2:  MOVLW  44
00EA4:  MOVWF  xB0
00EA6:  MOVLW  20
00EA8:  MOVWF  xB1
00EAA:  MOVLW  33
00EAC:  MOVWF  xB2
00EAE:  MOVLW  20
00EB0:  MOVWF  xB3
00EB2:  MOVLW  4F
00EB4:  MOVWF  xB4
00EB6:  MOVLW  46
00EB8:  MOVWF  xB5
00EBA:  MOVWF  xB6
00EBC:  CLRF   xB7
....................    char LED4ON[] = "LED 4 ON";
00EBE:  MOVLW  4C
00EC0:  MOVWF  xB8
00EC2:  MOVLW  45
00EC4:  MOVWF  xB9
00EC6:  MOVLW  44
00EC8:  MOVWF  xBA
00ECA:  MOVLW  20
00ECC:  MOVWF  xBB
00ECE:  MOVLW  34
00ED0:  MOVWF  xBC
00ED2:  MOVLW  20
00ED4:  MOVWF  xBD
00ED6:  MOVLW  4F
00ED8:  MOVWF  xBE
00EDA:  MOVLW  4E
00EDC:  MOVWF  xBF
00EDE:  CLRF   xC0
....................    char LED4OFF[] = "LED 4 OFF";
00EE0:  MOVLW  4C
00EE2:  MOVWF  xC1
00EE4:  MOVLW  45
00EE6:  MOVWF  xC2
00EE8:  MOVLW  44
00EEA:  MOVWF  xC3
00EEC:  MOVLW  20
00EEE:  MOVWF  xC4
00EF0:  MOVLW  34
00EF2:  MOVWF  xC5
00EF4:  MOVLW  20
00EF6:  MOVWF  xC6
00EF8:  MOVLW  4F
00EFA:  MOVWF  xC7
00EFC:  MOVLW  46
00EFE:  MOVWF  xC8
00F00:  MOVWF  xC9
00F02:  CLRF   xCA
....................    char LED1FLASH[] = "LED 1 FLASH";
00F04:  MOVLW  4C
00F06:  MOVWF  xCB
00F08:  MOVLW  45
00F0A:  MOVWF  xCC
00F0C:  MOVLW  44
00F0E:  MOVWF  xCD
00F10:  MOVLW  20
00F12:  MOVWF  xCE
00F14:  MOVLW  31
00F16:  MOVWF  xCF
00F18:  MOVLW  20
00F1A:  MOVWF  xD0
00F1C:  MOVLW  46
00F1E:  MOVWF  xD1
00F20:  MOVLW  4C
00F22:  MOVWF  xD2
00F24:  MOVLW  41
00F26:  MOVWF  xD3
00F28:  MOVLW  53
00F2A:  MOVWF  xD4
00F2C:  MOVLW  48
00F2E:  MOVWF  xD5
00F30:  CLRF   xD6
....................    char LED2FLASH[] = "LED 2 FLASH";
00F32:  MOVLW  4C
00F34:  MOVWF  xD7
00F36:  MOVLW  45
00F38:  MOVWF  xD8
00F3A:  MOVLW  44
00F3C:  MOVWF  xD9
00F3E:  MOVLW  20
00F40:  MOVWF  xDA
00F42:  MOVLW  32
00F44:  MOVWF  xDB
00F46:  MOVLW  20
00F48:  MOVWF  xDC
00F4A:  MOVLW  46
00F4C:  MOVWF  xDD
00F4E:  MOVLW  4C
00F50:  MOVWF  xDE
00F52:  MOVLW  41
00F54:  MOVWF  xDF
00F56:  MOVLW  53
00F58:  MOVWF  xE0
00F5A:  MOVLW  48
00F5C:  MOVWF  xE1
00F5E:  CLRF   xE2
....................    char LED3FLASH[] = "LED 3 FLASH";
00F60:  MOVLW  4C
00F62:  MOVWF  xE3
00F64:  MOVLW  45
00F66:  MOVWF  xE4
00F68:  MOVLW  44
00F6A:  MOVWF  xE5
00F6C:  MOVLW  20
00F6E:  MOVWF  xE6
00F70:  MOVLW  33
00F72:  MOVWF  xE7
00F74:  MOVLW  20
00F76:  MOVWF  xE8
00F78:  MOVLW  46
00F7A:  MOVWF  xE9
00F7C:  MOVLW  4C
00F7E:  MOVWF  xEA
00F80:  MOVLW  41
00F82:  MOVWF  xEB
00F84:  MOVLW  53
00F86:  MOVWF  xEC
00F88:  MOVLW  48
00F8A:  MOVWF  xED
00F8C:  CLRF   xEE
....................    char LED4FLASH[] = "LED 4 FLASH";
00F8E:  MOVLW  4C
00F90:  MOVWF  xEF
00F92:  MOVLW  45
00F94:  MOVWF  xF0
00F96:  MOVLW  44
00F98:  MOVWF  xF1
00F9A:  MOVLW  20
00F9C:  MOVWF  xF2
00F9E:  MOVLW  34
00FA0:  MOVWF  xF3
00FA2:  MOVLW  20
00FA4:  MOVWF  xF4
00FA6:  MOVLW  46
00FA8:  MOVWF  xF5
00FAA:  MOVLW  4C
00FAC:  MOVWF  xF6
00FAE:  MOVLW  41
00FB0:  MOVWF  xF7
00FB2:  MOVLW  53
00FB4:  MOVWF  xF8
00FB6:  MOVLW  48
00FB8:  MOVWF  xF9
00FBA:  CLRF   xFA
....................    char BRIGHTNESS[] = "BRIGHTNESS";
00FBC:  MOVLW  42
00FBE:  MOVWF  xFB
00FC0:  MOVLW  52
00FC2:  MOVWF  xFC
00FC4:  MOVLW  49
00FC6:  MOVWF  xFD
00FC8:  MOVLW  47
00FCA:  MOVWF  xFE
00FCC:  MOVLW  48
00FCE:  MOVWF  xFF
00FD0:  MOVLW  54
00FD2:  MOVLB  1
00FD4:  MOVWF  x00
00FD6:  MOVLW  4E
00FD8:  MOVWF  x01
00FDA:  MOVLW  45
00FDC:  MOVWF  x02
00FDE:  MOVLW  53
00FE0:  MOVWF  x03
00FE2:  MOVWF  x04
00FE4:  CLRF   x05
....................    int flash = 0;
....................    float value;
.................... 
....................    //string comparison to determine which operation to do
....................    if (strcmp(strupr(string), LED1ON) == 0) 
*
00FE8:  MOVFF  7E,10E
00FEC:  MOVFF  7D,10D
00FF0:  MOVLB  0
00FF2:  CALL   0448
00FF6:  MOVFF  02,10E
00FFA:  MOVFF  01,10D
00FFE:  MOVFF  02,110
01002:  MOVFF  01,10F
01006:  MOVLB  1
01008:  CLRF   x12
0100A:  MOVLW  7F
0100C:  MOVWF  x11
0100E:  MOVLB  0
01010:  CALL   04A8
01014:  MOVF   01,F
01016:  BNZ   1044
....................    {
....................       puts("OK\n");
01018:  MOVLW  1C
0101A:  MOVWF  FF6
0101C:  MOVLW  01
0101E:  MOVWF  FF7
01020:  MOVLW  00
01022:  MOVWF  FF8
01024:  CALL   0372
01028:  MOVLW  0D
0102A:  MOVLB  1
0102C:  MOVWF  x10
0102E:  MOVLB  0
01030:  CALL   035A
01034:  MOVLW  0A
01036:  MOVLB  1
01038:  MOVWF  x10
0103A:  MOVLB  0
0103C:  CALL   035A
....................       Port.LED1 = 0b1;
01040:  BSF    F8F.0
....................    }
01042:  BRA    15FC
....................    else if (strcmp(strupr(string), LED1OFF) == 0)
01044:  MOVFF  7E,10E
01048:  MOVFF  7D,10D
0104C:  CALL   0448
01050:  MOVFF  02,10E
01054:  MOVFF  01,10D
01058:  MOVFF  02,110
0105C:  MOVFF  01,10F
01060:  MOVLB  1
01062:  CLRF   x12
01064:  MOVLW  88
01066:  MOVWF  x11
01068:  MOVLB  0
0106A:  CALL   04A8
0106E:  MOVF   01,F
01070:  BNZ   109E
....................    {
....................       puts("OK\n");
01072:  MOVLW  20
01074:  MOVWF  FF6
01076:  MOVLW  01
01078:  MOVWF  FF7
0107A:  MOVLW  00
0107C:  MOVWF  FF8
0107E:  CALL   0372
01082:  MOVLW  0D
01084:  MOVLB  1
01086:  MOVWF  x10
01088:  MOVLB  0
0108A:  CALL   035A
0108E:  MOVLW  0A
01090:  MOVLB  1
01092:  MOVWF  x10
01094:  MOVLB  0
01096:  CALL   035A
....................       Port.LED1 = 0b0;
0109A:  BCF    F8F.0
....................    }
0109C:  BRA    15FC
....................    else if (strcmp(strupr(string), LED2ON) == 0)
0109E:  MOVFF  7E,10E
010A2:  MOVFF  7D,10D
010A6:  CALL   0448
010AA:  MOVFF  02,10E
010AE:  MOVFF  01,10D
010B2:  MOVFF  02,110
010B6:  MOVFF  01,10F
010BA:  MOVLB  1
010BC:  CLRF   x12
010BE:  MOVLW  92
010C0:  MOVWF  x11
010C2:  MOVLB  0
010C4:  CALL   04A8
010C8:  MOVF   01,F
010CA:  BNZ   10F8
....................    {
....................       puts("OK\n");
010CC:  MOVLW  24
010CE:  MOVWF  FF6
010D0:  MOVLW  01
010D2:  MOVWF  FF7
010D4:  MOVLW  00
010D6:  MOVWF  FF8
010D8:  CALL   0372
010DC:  MOVLW  0D
010DE:  MOVLB  1
010E0:  MOVWF  x10
010E2:  MOVLB  0
010E4:  CALL   035A
010E8:  MOVLW  0A
010EA:  MOVLB  1
010EC:  MOVWF  x10
010EE:  MOVLB  0
010F0:  CALL   035A
....................       Port.LED2 = 0b1;
010F4:  BSF    F8F.1
....................    }
010F6:  BRA    15FC
....................    else if (strcmp(strupr(string), LED2OFF) == 0)
010F8:  MOVFF  7E,10E
010FC:  MOVFF  7D,10D
01100:  CALL   0448
01104:  MOVFF  02,10E
01108:  MOVFF  01,10D
0110C:  MOVFF  02,110
01110:  MOVFF  01,10F
01114:  MOVLB  1
01116:  CLRF   x12
01118:  MOVLW  9B
0111A:  MOVWF  x11
0111C:  MOVLB  0
0111E:  CALL   04A8
01122:  MOVF   01,F
01124:  BNZ   1152
....................    {
....................       puts("OK\n");
01126:  MOVLW  28
01128:  MOVWF  FF6
0112A:  MOVLW  01
0112C:  MOVWF  FF7
0112E:  MOVLW  00
01130:  MOVWF  FF8
01132:  CALL   0372
01136:  MOVLW  0D
01138:  MOVLB  1
0113A:  MOVWF  x10
0113C:  MOVLB  0
0113E:  CALL   035A
01142:  MOVLW  0A
01144:  MOVLB  1
01146:  MOVWF  x10
01148:  MOVLB  0
0114A:  CALL   035A
....................       Port.LED2 = 0b0;
0114E:  BCF    F8F.1
....................    }
01150:  BRA    15FC
....................    else if (strcmp(strupr(string), LED3ON) == 0)
01152:  MOVFF  7E,10E
01156:  MOVFF  7D,10D
0115A:  CALL   0448
0115E:  MOVFF  02,10E
01162:  MOVFF  01,10D
01166:  MOVFF  02,110
0116A:  MOVFF  01,10F
0116E:  MOVLB  1
01170:  CLRF   x12
01172:  MOVLW  A5
01174:  MOVWF  x11
01176:  MOVLB  0
01178:  CALL   04A8
0117C:  MOVF   01,F
0117E:  BNZ   11AC
....................    {
....................       puts("OK\n");
01180:  MOVLW  2C
01182:  MOVWF  FF6
01184:  MOVLW  01
01186:  MOVWF  FF7
01188:  MOVLW  00
0118A:  MOVWF  FF8
0118C:  CALL   0372
01190:  MOVLW  0D
01192:  MOVLB  1
01194:  MOVWF  x10
01196:  MOVLB  0
01198:  CALL   035A
0119C:  MOVLW  0A
0119E:  MOVLB  1
011A0:  MOVWF  x10
011A2:  MOVLB  0
011A4:  CALL   035A
....................       Port.LED3 = 0b1;
011A8:  BSF    F8F.2
....................    }
011AA:  BRA    15FC
....................    else if (strcmp(strupr(string), LED3OFF) == 0)
011AC:  MOVFF  7E,10E
011B0:  MOVFF  7D,10D
011B4:  CALL   0448
011B8:  MOVFF  02,10E
011BC:  MOVFF  01,10D
011C0:  MOVFF  02,110
011C4:  MOVFF  01,10F
011C8:  MOVLB  1
011CA:  CLRF   x12
011CC:  MOVLW  AE
011CE:  MOVWF  x11
011D0:  MOVLB  0
011D2:  CALL   04A8
011D6:  MOVF   01,F
011D8:  BNZ   1206
....................    {
....................       puts("OK\n");
011DA:  MOVLW  30
011DC:  MOVWF  FF6
011DE:  MOVLW  01
011E0:  MOVWF  FF7
011E2:  MOVLW  00
011E4:  MOVWF  FF8
011E6:  CALL   0372
011EA:  MOVLW  0D
011EC:  MOVLB  1
011EE:  MOVWF  x10
011F0:  MOVLB  0
011F2:  CALL   035A
011F6:  MOVLW  0A
011F8:  MOVLB  1
011FA:  MOVWF  x10
011FC:  MOVLB  0
011FE:  CALL   035A
....................       Port.LED3 = 0b0;
01202:  BCF    F8F.2
....................    }
01204:  BRA    15FC
....................    else if (strcmp(strupr(string), LED4ON) == 0)
01206:  MOVFF  7E,10E
0120A:  MOVFF  7D,10D
0120E:  CALL   0448
01212:  MOVFF  02,10E
01216:  MOVFF  01,10D
0121A:  MOVFF  02,110
0121E:  MOVFF  01,10F
01222:  MOVLB  1
01224:  CLRF   x12
01226:  MOVLW  B8
01228:  MOVWF  x11
0122A:  MOVLB  0
0122C:  CALL   04A8
01230:  MOVF   01,F
01232:  BNZ   1260
....................    {
....................       puts("OK\n");
01234:  MOVLW  34
01236:  MOVWF  FF6
01238:  MOVLW  01
0123A:  MOVWF  FF7
0123C:  MOVLW  00
0123E:  MOVWF  FF8
01240:  CALL   0372
01244:  MOVLW  0D
01246:  MOVLB  1
01248:  MOVWF  x10
0124A:  MOVLB  0
0124C:  CALL   035A
01250:  MOVLW  0A
01252:  MOVLB  1
01254:  MOVWF  x10
01256:  MOVLB  0
01258:  CALL   035A
....................       Port.LED4 = 0b1;
0125C:  BSF    F8F.3
....................    }
0125E:  BRA    15FC
....................    else if (strcmp(strupr(string), LED4OFF) == 0)
01260:  MOVFF  7E,10E
01264:  MOVFF  7D,10D
01268:  CALL   0448
0126C:  MOVFF  02,10E
01270:  MOVFF  01,10D
01274:  MOVFF  02,110
01278:  MOVFF  01,10F
0127C:  MOVLB  1
0127E:  CLRF   x12
01280:  MOVLW  C1
01282:  MOVWF  x11
01284:  MOVLB  0
01286:  CALL   04A8
0128A:  MOVF   01,F
0128C:  BNZ   12BA
....................    {
....................       puts("OK\n");
0128E:  MOVLW  38
01290:  MOVWF  FF6
01292:  MOVLW  01
01294:  MOVWF  FF7
01296:  MOVLW  00
01298:  MOVWF  FF8
0129A:  CALL   0372
0129E:  MOVLW  0D
012A0:  MOVLB  1
012A2:  MOVWF  x10
012A4:  MOVLB  0
012A6:  CALL   035A
012AA:  MOVLW  0A
012AC:  MOVLB  1
012AE:  MOVWF  x10
012B0:  MOVLB  0
012B2:  CALL   035A
....................       Port.LED4 = 0b0;
012B6:  BCF    F8F.3
....................    }
012B8:  BRA    15FC
....................    else if (strcmp(strupr(string), LED1FLASH) == 0)
012BA:  MOVFF  7E,10E
012BE:  MOVFF  7D,10D
012C2:  CALL   0448
012C6:  MOVFF  02,10E
012CA:  MOVFF  01,10D
012CE:  MOVFF  02,110
012D2:  MOVFF  01,10F
012D6:  MOVLB  1
012D8:  CLRF   x12
012DA:  MOVLW  CB
012DC:  MOVWF  x11
012DE:  MOVLB  0
012E0:  CALL   04A8
012E4:  MOVF   01,F
012E6:  BNZ   1330
....................    {
....................       puts("OK\n");
012E8:  MOVLW  3C
012EA:  MOVWF  FF6
012EC:  MOVLW  01
012EE:  MOVWF  FF7
012F0:  MOVLW  00
012F2:  MOVWF  FF8
012F4:  CALL   0372
012F8:  MOVLW  0D
012FA:  MOVLB  1
012FC:  MOVWF  x10
012FE:  MOVLB  0
01300:  CALL   035A
01304:  MOVLW  0A
01306:  MOVLB  1
01308:  MOVWF  x10
0130A:  MOVLB  0
0130C:  CALL   035A
....................       for(flash = 0; flash < 10; flash++)
01310:  MOVLB  1
01312:  CLRF   x06
01314:  MOVF   x06,W
01316:  SUBLW  09
01318:  BNC   132C
....................       {
....................          Port.LED1 = ~Port.LED1;
0131A:  BTG    F8F.0
....................          delay_ms(80);
0131C:  MOVLW  50
0131E:  MOVWF  x0D
01320:  MOVLB  0
01322:  CALL   0520
01326:  MOVLB  1
01328:  INCF   x06,F
0132A:  BRA    1314
....................       }
....................    }
0132C:  BRA    15FE
0132E:  MOVLB  0
....................    else if (strcmp(strupr(string), LED2FLASH) == 0)
01330:  MOVFF  7E,10E
01334:  MOVFF  7D,10D
01338:  CALL   0448
0133C:  MOVFF  02,10E
01340:  MOVFF  01,10D
01344:  MOVFF  02,110
01348:  MOVFF  01,10F
0134C:  MOVLB  1
0134E:  CLRF   x12
01350:  MOVLW  D7
01352:  MOVWF  x11
01354:  MOVLB  0
01356:  CALL   04A8
0135A:  MOVF   01,F
0135C:  BNZ   13A6
....................    {
....................       puts("OK\n");
0135E:  MOVLW  40
01360:  MOVWF  FF6
01362:  MOVLW  01
01364:  MOVWF  FF7
01366:  MOVLW  00
01368:  MOVWF  FF8
0136A:  CALL   0372
0136E:  MOVLW  0D
01370:  MOVLB  1
01372:  MOVWF  x10
01374:  MOVLB  0
01376:  CALL   035A
0137A:  MOVLW  0A
0137C:  MOVLB  1
0137E:  MOVWF  x10
01380:  MOVLB  0
01382:  CALL   035A
....................       for(flash = 0; flash < 10; flash++)
01386:  MOVLB  1
01388:  CLRF   x06
0138A:  MOVF   x06,W
0138C:  SUBLW  09
0138E:  BNC   13A2
....................       {
....................          Port.LED2 = ~Port.LED2;
01390:  BTG    F8F.1
....................          delay_ms(80);
01392:  MOVLW  50
01394:  MOVWF  x0D
01396:  MOVLB  0
01398:  CALL   0520
0139C:  MOVLB  1
0139E:  INCF   x06,F
013A0:  BRA    138A
....................       }
....................    }
013A2:  BRA    15FE
013A4:  MOVLB  0
....................    else if (strcmp(strupr(string), LED3FLASH) == 0)
013A6:  MOVFF  7E,10E
013AA:  MOVFF  7D,10D
013AE:  CALL   0448
013B2:  MOVFF  02,10E
013B6:  MOVFF  01,10D
013BA:  MOVFF  02,110
013BE:  MOVFF  01,10F
013C2:  MOVLB  1
013C4:  CLRF   x12
013C6:  MOVLW  E3
013C8:  MOVWF  x11
013CA:  MOVLB  0
013CC:  CALL   04A8
013D0:  MOVF   01,F
013D2:  BNZ   141C
....................    {
....................       puts("OK\n");
013D4:  MOVLW  44
013D6:  MOVWF  FF6
013D8:  MOVLW  01
013DA:  MOVWF  FF7
013DC:  MOVLW  00
013DE:  MOVWF  FF8
013E0:  CALL   0372
013E4:  MOVLW  0D
013E6:  MOVLB  1
013E8:  MOVWF  x10
013EA:  MOVLB  0
013EC:  CALL   035A
013F0:  MOVLW  0A
013F2:  MOVLB  1
013F4:  MOVWF  x10
013F6:  MOVLB  0
013F8:  CALL   035A
....................       for(flash = 0; flash < 10; flash++)
013FC:  MOVLB  1
013FE:  CLRF   x06
01400:  MOVF   x06,W
01402:  SUBLW  09
01404:  BNC   1418
....................       {
....................          Port.LED3 = ~Port.LED3;
01406:  BTG    F8F.2
....................          delay_ms(80);
01408:  MOVLW  50
0140A:  MOVWF  x0D
0140C:  MOVLB  0
0140E:  CALL   0520
01412:  MOVLB  1
01414:  INCF   x06,F
01416:  BRA    1400
....................       }
....................    }
01418:  BRA    15FE
0141A:  MOVLB  0
....................    else if (strcmp(strupr(string), LED4FLASH) == 0)
0141C:  MOVFF  7E,10E
01420:  MOVFF  7D,10D
01424:  CALL   0448
01428:  MOVFF  02,10E
0142C:  MOVFF  01,10D
01430:  MOVFF  02,110
01434:  MOVFF  01,10F
01438:  MOVLB  1
0143A:  CLRF   x12
0143C:  MOVLW  EF
0143E:  MOVWF  x11
01440:  MOVLB  0
01442:  CALL   04A8
01446:  MOVF   01,F
01448:  BNZ   1492
....................    {
....................       puts("OK\n");
0144A:  MOVLW  48
0144C:  MOVWF  FF6
0144E:  MOVLW  01
01450:  MOVWF  FF7
01452:  MOVLW  00
01454:  MOVWF  FF8
01456:  CALL   0372
0145A:  MOVLW  0D
0145C:  MOVLB  1
0145E:  MOVWF  x10
01460:  MOVLB  0
01462:  CALL   035A
01466:  MOVLW  0A
01468:  MOVLB  1
0146A:  MOVWF  x10
0146C:  MOVLB  0
0146E:  CALL   035A
....................       for(flash = 0; flash < 10; flash++)
01472:  MOVLB  1
01474:  CLRF   x06
01476:  MOVF   x06,W
01478:  SUBLW  09
0147A:  BNC   148E
....................       {
....................          Port.LED4 = ~Port.LED4;
0147C:  BTG    F8F.3
....................          delay_ms(80);
0147E:  MOVLW  50
01480:  MOVWF  x0D
01482:  MOVLB  0
01484:  CALL   0520
01488:  MOVLB  1
0148A:  INCF   x06,F
0148C:  BRA    1476
....................       }
....................    }
0148E:  BRA    15FE
01490:  MOVLB  0
....................    else if (strstr(strupr(string), BRIGHTNESS))
01492:  MOVFF  7E,10E
01496:  MOVFF  7D,10D
0149A:  CALL   0448
0149E:  MOVFF  02,10E
014A2:  MOVFF  01,10D
014A6:  MOVFF  02,110
014AA:  MOVFF  01,10F
014AE:  MOVLB  1
014B0:  CLRF   x12
014B2:  MOVLW  FB
014B4:  MOVWF  x11
014B6:  MOVLB  0
014B8:  GOTO   0548
014BC:  MOVF   01,W
014BE:  IORWF  02,W
014C0:  BTFSC  FD8.2
014C2:  BRA    15D4
....................    {
....................       puts("OK\n");
014C4:  MOVLW  4C
014C6:  MOVWF  FF6
014C8:  MOVLW  01
014CA:  MOVWF  FF7
014CC:  MOVLW  00
014CE:  MOVWF  FF8
014D0:  CALL   0372
014D4:  MOVLW  0D
014D6:  MOVLB  1
014D8:  MOVWF  x10
014DA:  MOVLB  0
014DC:  CALL   035A
014E0:  MOVLW  0A
014E2:  MOVLB  1
014E4:  MOVWF  x10
014E6:  MOVLB  0
014E8:  CALL   035A
....................       value = GetBrightness(string)/10;
014EC:  MOVFF  7E,10E
014F0:  MOVFF  7D,10D
014F4:  BRA    0D16
014F6:  MOVFF  03,110
014FA:  MOVFF  02,10F
014FE:  MOVFF  01,10E
01502:  MOVFF  00,10D
01506:  MOVFF  03,12B
0150A:  MOVFF  02,12A
0150E:  MOVFF  01,129
01512:  MOVFF  00,128
01516:  MOVLB  1
01518:  CLRF   x2F
0151A:  CLRF   x2E
0151C:  MOVLW  20
0151E:  MOVWF  x2D
01520:  MOVLW  82
01522:  MOVWF  x2C
01524:  MOVLB  0
01526:  CALL   06F4
0152A:  MOVFF  03,10A
0152E:  MOVFF  02,109
01532:  MOVFF  01,108
01536:  MOVFF  00,107
....................       //for a clock running at 32MHz
....................      //brightness is given in percent and the full scale duty cycle is 2^10 = 1024     
....................       int16 a = ((value*256)/100); // to convert brightness to duty cycle brightness/100 * 1024/4    
0153A:  MOVFF  10A,127
0153E:  MOVFF  109,126
01542:  MOVFF  108,125
01546:  MOVFF  107,124
0154A:  MOVLB  1
0154C:  CLRF   x2B
0154E:  CLRF   x2A
01550:  CLRF   x29
01552:  MOVLW  87
01554:  MOVWF  x28
01556:  MOVLB  0
01558:  CALL   05C8
0155C:  MOVFF  03,110
01560:  MOVFF  02,10F
01564:  MOVFF  01,10E
01568:  MOVFF  00,10D
0156C:  MOVFF  03,12B
01570:  MOVFF  02,12A
01574:  MOVFF  01,129
01578:  MOVFF  00,128
0157C:  MOVLB  1
0157E:  CLRF   x2F
01580:  CLRF   x2E
01582:  MOVLW  48
01584:  MOVWF  x2D
01586:  MOVLW  85
01588:  MOVWF  x2C
0158A:  MOVLB  0
0158C:  CALL   06F4
01590:  MOVFF  03,110
01594:  MOVFF  02,10F
01598:  MOVFF  01,10E
0159C:  MOVFF  00,10D
015A0:  BRA    0DAE
015A2:  MOVFF  02,10C
015A6:  MOVFF  01,10B
....................       set_pwm4_duty(a);
015AA:  MOVFF  10C,02
015AE:  MOVFF  10B,01
015B2:  RLCF   01,F
015B4:  RLCF   02,F
015B6:  RLCF   01,F
015B8:  RLCF   02,F
015BA:  RLCF   01,F
015BC:  RLCF   02,F
015BE:  RLCF   01,F
015C0:  RLCF   02,F
015C2:  RLCF   01,F
015C4:  RLCF   02,F
015C6:  RLCF   01,F
015C8:  RLCF   02,F
015CA:  MOVFF  02,FA1
015CE:  MOVFF  01,FA0
....................    }
015D2:  BRA    15FC
....................    else
....................    {  //if anything other than the available commands are typed, outputs error
....................       puts("Invalid Input! Try Again.\n");
015D4:  MOVLW  50
015D6:  MOVWF  FF6
015D8:  MOVLW  01
015DA:  MOVWF  FF7
015DC:  MOVLW  00
015DE:  MOVWF  FF8
015E0:  CALL   0372
015E4:  MOVLW  0D
015E6:  MOVLB  1
015E8:  MOVWF  x10
015EA:  MOVLB  0
015EC:  CALL   035A
015F0:  MOVLW  0A
015F2:  MOVLB  1
015F4:  MOVWF  x10
015F6:  MOVLB  0
015F8:  CALL   035A
015FC:  MOVLB  1
....................    }
015FE:  MOVLB  0
01600:  GOTO   18A2 (RETURN)
.................... }//end receive command
.................... 
.................... void main ()
01604:  BSF    F81.7
01606:  BCF    F81.6
01608:  CLRF   FF8
0160A:  BCF    FF2.5
0160C:  BSF    07.7
0160E:  MOVLB  E
01610:  MOVLW  55
01612:  MOVWF  xA0
01614:  MOVLW  AA
01616:  MOVWF  xA0
01618:  BCF    xA0.0
0161A:  MOVLW  17
0161C:  MOVWF  xB5
0161E:  MOVLW  08
01620:  MOVWF  xFB
01622:  MOVWF  xFC
01624:  MOVLW  09
01626:  MOVWF  xFD
01628:  MOVLW  55
0162A:  MOVWF  xA0
0162C:  MOVLW  AA
0162E:  MOVWF  xA0
01630:  BSF    xA0.0
01632:  CLRF   xDD
01634:  CLRF   xDA
01636:  CLRF   xDC
01638:  MOVLW  06
0163A:  MOVWF  xDE
0163C:  MOVLW  60
0163E:  MOVWF  xD8
01640:  CLRF   22
01642:  BSF    F9F.3
01644:  MOVLW  40
01646:  MOVWF  F9B
01648:  MOVLW  03
0164A:  MOVWF  F9C
0164C:  MOVLW  A6
0164E:  MOVWF  F9E
01650:  MOVLW  90
01652:  MOVWF  F9D
01654:  CLRF   43
01656:  CLRF   44
01658:  CLRF   5A
0165A:  CLRF   59
0165C:  MOVLB  F
0165E:  CLRF   x11
01660:  CLRF   x19
01662:  CLRF   x21
01664:  CLRF   x3A
01666:  CLRF   x3B
01668:  CLRF   x3C
0166A:  CLRF   x39
0166C:  CLRF   x36
0166E:  CLRF   x37
01670:  CLRF   x38
01672:  CLRF   x35
01674:  CLRF   1C
01676:  CLRF   1D
01678:  BCF    5B.0
.................... {
....................    short int startup = FALSE;   //boolean for first time opening Putty
....................    char kbhit;                  //pressing keyboard
....................    char command[RS232BUFFSIZE]; //string array to place characters from buffer
....................    
....................    //Pin directions
....................    Direction.unused_A = 0b00000000; //all unused set as output
0167A:  CLRF   F88
....................    Direction.unused_B = 0b00000000;
0167C:  CLRF   F89
....................    Direction.LED1 = 0b0;            //LEDs as output
0167E:  BCF    F8A.0
....................    Direction.LED2 = 0b0;
01680:  BCF    F8A.1
....................    Direction.LED3 = 0b0;
01682:  BCF    F8A.2
....................    Direction.LED4 = 0b0;
01684:  BCF    F8A.3
....................    Direction.unused_C = 0b00;
01686:  MOVLW  CF
01688:  ANDWF  F8A,W
0168A:  MOVWF  F8A
....................    Direction.TXPin = 0b0;           //2 pins to FTDI, TX is transmit (output from PIC)
0168C:  BCF    F8A.6
....................    Direction.RXPin = 0b1;           //RX is receive (input to PIC)
0168E:  BSF    F8A.7
....................    
....................    setup_ccp2(CCP_PWM | CCP_USE_TIMER1_AND_TIMER2);        //Configure CCP2 as PWM
01690:  MOVLW  0C
01692:  MOVWF  FA8
01694:  MOVLW  F3
01696:  ANDWF  FAE,F
01698:  MOVLW  04
0169A:  IORWF  FAE,F
0169C:  BSF    FA8.7
....................    setup_pwm4(PWM_ENABLED | PWM_ACTIVE_HIGH | PWM_TIMER2); //enabling pwm
0169E:  BCF    F8A.4
016A0:  MOVF   FAE,W
016A2:  ANDLW  3F
016A4:  IORLW  40
016A6:  MOVWF  FAE
016A8:  MOVLW  80
016AA:  MOVWF  FA2
....................    setup_timer_2(T2_CLK_INTERNAL|T2_DIV_BY_1, 249, 1);     //prescaler, PR, postscaler
016AC:  CLRF   FC0
016AE:  CLRF   FBE
016B0:  MOVLW  01
016B2:  MOVWF  FBF
016B4:  MOVLW  F9
016B6:  MOVWF  FBC
016B8:  MOVLW  80
016BA:  MOVWF  FBD
....................    
....................    enable_interrupts(INT_RDA); //Initializing System and interrupts
016BC:  MOVLB  E
016BE:  BSF    xC5.5
....................    if (kbhit())                
016C0:  BTFSS  xCD.5
016C2:  BRA    16CC
....................       fgetc(Serial_Stream);
016C4:  MOVLB  0
016C6:  CALL   00C0
016CA:  MOVLB  E
....................    enable_interrupts(GLOBAL);
016CC:  MOVLW  C0
016CE:  IORWF  FF2,F
.................... 
....................    While(Forever)
....................    {
....................       while (startup == FALSE) //occurs only once, title and explanation at top of Putty, neat and tidy
016D0:  BTFSC  5B.0
016D2:  BRA    1824
....................       {
....................          if (RS232_next_in != 0)
016D4:  MOVF   43,F
016D6:  BTFSC  FD8.2
016D8:  BRA    1822
....................          {
....................             puts("\t\t***Group 23 EE2A Lab 6***\n\r");
016DA:  MOVLW  6C
016DC:  MOVWF  FF6
016DE:  MOVLW  01
016E0:  MOVWF  FF7
016E2:  MOVLW  00
016E4:  MOVWF  FF8
016E6:  MOVLB  0
016E8:  CALL   0372
016EC:  MOVLW  0D
016EE:  MOVLB  1
016F0:  MOVWF  x10
016F2:  MOVLB  0
016F4:  CALL   035A
016F8:  MOVLW  0A
016FA:  MOVLB  1
016FC:  MOVWF  x10
016FE:  MOVLB  0
01700:  CALL   035A
....................             puts("Available Commands:\n");
01704:  MOVLW  8A
01706:  MOVWF  FF6
01708:  MOVLW  01
0170A:  MOVWF  FF7
0170C:  MOVLW  00
0170E:  MOVWF  FF8
01710:  CALL   0372
01714:  MOVLW  0D
01716:  MOVLB  1
01718:  MOVWF  x10
0171A:  MOVLB  0
0171C:  CALL   035A
01720:  MOVLW  0A
01722:  MOVLB  1
01724:  MOVWF  x10
01726:  MOVLB  0
01728:  CALL   035A
....................             puts("   -Turning LEDs ON-         -Turning LEDs OFF-          -Flashing LEDs-\n");
0172C:  MOVLW  A0
0172E:  MOVWF  FF6
01730:  MOVLW  01
01732:  MOVWF  FF7
01734:  MOVLW  00
01736:  MOVWF  FF8
01738:  CALL   0372
0173C:  MOVLW  0D
0173E:  MOVLB  1
01740:  MOVWF  x10
01742:  MOVLB  0
01744:  CALL   035A
01748:  MOVLW  0A
0174A:  MOVLB  1
0174C:  MOVWF  x10
0174E:  MOVLB  0
01750:  CALL   035A
....................             puts("       LED x on                  LED x off                 LED x flash\n\r");
01754:  MOVLW  EA
01756:  MOVWF  FF6
01758:  MOVLW  01
0175A:  MOVWF  FF7
0175C:  MOVLW  00
0175E:  MOVWF  FF8
01760:  CALL   0372
01764:  MOVLW  0D
01766:  MOVLB  1
01768:  MOVWF  x10
0176A:  MOVLB  0
0176C:  CALL   035A
01770:  MOVLW  0A
01772:  MOVLB  1
01774:  MOVWF  x10
01776:  MOVLB  0
01778:  CALL   035A
....................             puts("Where x = 1,2,3 or 4\n\rlower and uppercase does not matter\n\r");
0177C:  MOVLW  34
0177E:  MOVWF  FF6
01780:  MOVLW  02
01782:  MOVWF  FF7
01784:  MOVLW  00
01786:  MOVWF  FF8
01788:  CALL   0372
0178C:  MOVLW  0D
0178E:  MOVLB  1
01790:  MOVWF  x10
01792:  MOVLB  0
01794:  CALL   035A
01798:  MOVLW  0A
0179A:  MOVLB  1
0179C:  MOVWF  x10
0179E:  MOVLB  0
017A0:  CALL   035A
....................             puts("IMPORTANT: Space are required!!! Backspace does not work!\n\r");
017A4:  MOVLW  70
017A6:  MOVWF  FF6
017A8:  MOVLW  02
017AA:  MOVWF  FF7
017AC:  MOVLW  00
017AE:  MOVWF  FF8
017B0:  CALL   0372
017B4:  MOVLW  0D
017B6:  MOVLB  1
017B8:  MOVWF  x10
017BA:  MOVLB  0
017BC:  CALL   035A
017C0:  MOVLW  0A
017C2:  MOVLB  1
017C4:  MOVWF  x10
017C6:  MOVLB  0
017C8:  CALL   035A
....................             puts("-Changing LED Brightness-\n");
017CC:  MOVLW  AC
017CE:  MOVWF  FF6
017D0:  MOVLW  02
017D2:  MOVWF  FF7
017D4:  MOVLW  00
017D6:  MOVWF  FF8
017D8:  CALL   0372
017DC:  MOVLW  0D
017DE:  MOVLB  1
017E0:  MOVWF  x10
017E2:  MOVLB  0
017E4:  CALL   035A
017E8:  MOVLW  0A
017EA:  MOVLB  1
017EC:  MOVWF  x10
017EE:  MOVLB  0
017F0:  CALL   035A
....................             puts("Brightness[value], where value = 0 - 99 (positive numbers)\n\r--------------------------------------------\n\r");
017F4:  MOVLW  C8
017F6:  MOVWF  FF6
017F8:  MOVLW  02
017FA:  MOVWF  FF7
017FC:  MOVLW  00
017FE:  MOVWF  FF8
01800:  CALL   0372
01804:  MOVLW  0D
01806:  MOVLB  1
01808:  MOVWF  x10
0180A:  MOVLB  0
0180C:  CALL   035A
01810:  MOVLW  0A
01812:  MOVLB  1
01814:  MOVWF  x10
01816:  MOVLB  0
01818:  CALL   035A
....................             startup = TRUE;
0181C:  BSF    5B.0
....................             break;
0181E:  MOVLB  E
01820:  BRA    1824
....................          }
01822:  BRA    16D0
....................       }
....................       if (RS232_next_in != RS232_next_out)         //as long as the loop has not restarted
01824:  MOVF   44,W
01826:  SUBWF  43,W
01828:  BZ    18A8
....................       {
....................          kbhit = RS232_buffer[RS232_next_out];     //puts characters from buffer into single character
0182A:  CLRF   03
0182C:  MOVF   44,W
0182E:  ADDLW  23
01830:  MOVWF  FE9
01832:  MOVLW  00
01834:  ADDWFC 03,W
01836:  MOVWF  FEA
01838:  MOVFF  FEF,5C
....................          putc(kbhit);                              //prints characters hit from keyboard
0183C:  MOVFF  5C,110
01840:  MOVLB  0
01842:  CALL   035A
....................          RS232_next_out = (RS232_next_out+1)%RS232BUFFSIZE;
01846:  MOVLW  01
01848:  ADDWF  44,W
0184A:  ANDLW  1F
0184C:  MOVWF  44
....................          if (kbhit == '\r')                        //when pressing enter
0184E:  MOVF   5C,W
01850:  SUBLW  0D
01852:  BNZ   18A6
....................          {
....................             puts('\n');                            //new line
01854:  CLRF   FEA
01856:  MOVLW  0A
01858:  MOVWF  FE9
0185A:  GOTO   039A
0185E:  MOVLW  0D
01860:  MOVLB  1
01862:  MOVWF  x10
01864:  MOVLB  0
01866:  CALL   035A
0186A:  MOVLW  0A
0186C:  MOVLB  1
0186E:  MOVWF  x10
01870:  MOVLB  0
01872:  CALL   035A
....................             strcpy(command, GetCom(RS232_buffer)); //send to command and get rid of spaces
01876:  CLRF   x7E
01878:  MOVLW  23
0187A:  MOVWF  x7D
0187C:  GOTO   03C0
01880:  MOVFF  01,7D
01884:  CLRF   FEA
01886:  MOVLW  5D
01888:  MOVWF  FE9
0188A:  CLRF   FE2
0188C:  MOVFF  01,FE1
01890:  MOVF   FE7,F
01892:  MOVFF  FE6,FEE
01896:  BNZ   1890
....................             Cmd_Receive(command);                  //send string to operation
01898:  CLRF   x7E
0189A:  MOVLW  5D
0189C:  MOVWF  x7D
0189E:  GOTO   0DEC
....................             RS232_next_out = 0; RS232_next_in = 0; //reset to 0 when enter
018A2:  CLRF   44
018A4:  CLRF   43
018A6:  MOVLB  E
....................          }
....................       }
018A8:  BRA    16D0
....................    }//end while
.................... }//end main
018AA:  SLEEP 

Configuration Fuses:
   Word  1: FEEC   NOEXTOSC RSTOSC_HFINTRC_1MHZ CLKOUT CKS FCMEN
   Word  2: FFFC   NOMCLR PUT NOLPBOR BROWNOUT BORV24 ZCDDIS PPS1WAY STVREN NODEBUG NOXINST
   Word  3: FF9F   WDTSW NOWDT WDTWIN_SW WDTCLK_SW
   Word  4: DFFF   NOWRT NOWRTC NOWRTB NOWRTD SCANE NOLVP
   Word  5: FFFF   NOPROTECT NOCPD
   Word  6: FFFF   NOEBTR NOEBTRB
